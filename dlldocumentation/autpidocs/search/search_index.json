{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ModCS","text":"<p>This is a new site for the documentation of ModCS, a Cave Story modding lua scripting API. It allows you to make custom hud elements, easily modify and make NPCs, create custom weapons and create custom TextScript commands.</p> <p>This project originally was developed by aikyuu and yasinbread, and the old site for ModCS is now currently out-of-date with the new features that have been added since.</p> <p>The current day of ModCS would not be the same without their hard work, so thank them for the creation of this tool!</p>"},{"location":"options/","title":"Extra Options","text":"<p>Vanilla Cave Story has some extra functionality if certain empty files without file extension are present in the same directory as the EXE.</p>"},{"location":"options/#vanilla-options","title":"Vanilla Options","text":"<ul> <li><code>s_reverse</code> - Swaps the weapon switch keys.</li> <li><code>mute</code> - Unhides a context menu which opens a window for muting different Organya channels.</li> <li><code>fps</code> - Enables a Framerate counter.</li> </ul>"},{"location":"api/camera/","title":"ModCS.Camera","text":"<p>The ModCS.Camera namespace contains functions related to the in-game camera.</p>"},{"location":"api/camera/#modcscamerasettarget","title":"ModCS.Camera.SetTarget()","text":"<pre><code>ModCS.Camera.SetTarget(obj)\n</code></pre> <p>Sets the camera target to Game object <code>obj</code> (Can be ModCS.Player, a ModCS.Npc, a ModCS.Caret or a ModCS.Bullet)</p>"},{"location":"api/camera/#modcscamerasetdelay","title":"ModCS.Camera.SetDelay()","text":"<pre><code>ModCS.Camera.SetDelay(x)\n</code></pre> <p>Sets the camera delay to <code>x</code> (Default is 16).</p>"},{"location":"api/camera/#modcscamerareset","title":"ModCS.Camera.Reset()","text":"<pre><code>ModCS.Camera.Reset()\n</code></pre> <p>Resets the camera position to the player.</p>"},{"location":"api/camera/#modcscameragetxpos","title":"ModCS.Camera.GetXPos()","text":"<pre><code>ModCS.Camera.GetXPos()\n</code></pre> <p>Returns the camera's X axis position in Pixel Units.</p>"},{"location":"api/camera/#modcscameragetypos","title":"ModCS.Camera.GetYPos()","text":"<pre><code>ModCS.Camera.GetYPos()\n</code></pre> <p>Returns the camera's Y axis position in Pixel Units.</p>"},{"location":"api/camera/#modcscamerasetquake","title":"ModCS.Camera.SetQuake()","text":"<pre><code>ModCS.Camera.SetQuake(time)\n</code></pre> <p>Makes the camera shake for <code>time</code> ticks.</p>"},{"location":"api/deprecated/","title":"Deprecated Features","text":"<p>These features have been deprecated and it's recommended not to use them.</p>"},{"location":"api/deprecated/#modcsorganya","title":"ModCS.Organya","text":"<p>ModCS.Organya was the namespace for playing music before ModCS 0.2.1.0. It was renamed to comply with the planned feature of playing WAV/OGG files as music.</p>"},{"location":"api/deprecated/#modcsrectput2surface","title":"ModCS.Rect.Put2Surface()","text":"<pre><code>ModCS.Rect.Put2Surface(rect, x, y, surfacefrom, surfaceto)\n</code></pre> <p>Draw the given Rect from the surface with ID <code>surfacefrom</code> to the surface with ID <code>surfaceto</code>.</p> <p>This has been deprecated in favor of ModCS.Rect.Put()  being able to draw to a Surface since ModCS 0.2.0.0.</p>"},{"location":"api/deprecated/#old-way-of-defining-game-object-act-functions","title":"Old way of defining game object Act functions.","text":"<p>Before ModCS 0.2.0.0 the default way to define custom Act functions of NPCs was <code>ModCS.Npc.ActX</code> or <code>ModCS.Caret.ActX</code> where X was the Game object type ID.</p> <p>This was deprecated in favor of an <code>Act</code> array contained in the game objects' class namespaces.</p>"},{"location":"api/game/","title":"ModCS.Game","text":"<p>Functions related to the main game loop. Stored in the ModCS.Game object.</p> <p>Warning</p> <p>The main game loop does not include:</p> <ul> <li>The inventory screen</li> <li>The stage select screen</li> <li>Minimap screen</li> <li>Credits</li> <li>Pause screen</li> </ul> <p>Functions such as ModCS.Game.Act() and ModCS.Game.Draw() will not run during these screens.</p>"},{"location":"api/game/#modcsgamegetmode","title":"ModCS.Game.GetMode()","text":"<pre><code>ModCS.Game.GetMode()\n</code></pre> <p>Return a number that represents the current game mode.</p> Value Game mode 1 Opening sequence. 2 Title screen. 3 Action."},{"location":"api/game/#modcsgameisnew","title":"ModCS.Game.IsNew()","text":"<pre><code>ModCS.Game.IsNew()\n</code></pre> <p>Returns true if the 'New' option in the title screen was selected. Returns false otherwise.</p>"},{"location":"api/game/#modcsgameinit","title":"ModCS.Game.Init()","text":"<p>This function is called whenever a game mode is started.</p> Example <p>This example will clear a variable <code>foo</code> on every game mode start. <pre><code>function ModCS.Game.Init()\n    -- Clear our foo variable\n    foo = 0\nend\n</code></pre></p>"},{"location":"api/game/#modcsgamecancontrol","title":"ModCS.Game.CanControl()","text":"<pre><code>ModCS.Game.CanControl()\n</code></pre> <p>Returns false during a <code>&lt;KEY</code> or <code>&lt;PRI</code>. Returns true otherwise.</p>"},{"location":"api/game/#modcsgamecanact","title":"ModCS.Game.CanAct()","text":"<pre><code>ModCS.Game.CanAct()\n</code></pre> <p>Returns false during a <code>&lt;PRI</code>. Returns true otherwise.</p>"},{"location":"api/game/#modcsgameact","title":"ModCS.Game.Act()","text":"<p>This function is called every frame before anything is updated or drawn in the main game loop.</p> Example <p>This example will add 1 to a variable <code>foo</code> every frame. <pre><code>function ModCS.Game.Act()\n    -- Add 1 to our foo variable every frame\n    foo = foo + 1\nend\n</code></pre></p>"},{"location":"api/game/#modcsgameupdate","title":"ModCS.Game.Update()","text":"<p>This function is called every frame before anything is drawn in the main game loop. It differentiates from ModCS.Game.Act only on when exactly it's ran.</p>"},{"location":"api/game/#modcsgamedraw","title":"ModCS.Game.Draw()","text":"<p>This function is called every frame after everything is drawn in the main game loop.</p> Example <p>This example will draw the value of the variable <code>foo</code> using ModCS.PutNumber. <pre><code>function ModCS.Game.Draw()\n    -- Draw the value of our variable\n    ModCS.PutNumber(foo, 0, 0)\nend\n</code></pre></p> <p>Note</p> <p>ModCS.Game.Draw() will draw over everything. If you're planning on using it for custom HUD it's recommended to draw to the custom HUD Surface instead.</p>"},{"location":"api/key/","title":"ModCS.Key","text":"<p>The ModCS.Key namespace contains functions for checking key presses.</p> <p>All ModCS.Key functions follow a similar format:</p> <pre><code>ModCS.Key.Button(hold)\n</code></pre> <p>Returns <code>true</code> if the button is being pressed.</p> <p><code>hold</code> is an optional parameter and a Boolean. If set to <code>true</code> the function will return true if the button is being held.</p>"},{"location":"api/key/#list-of-functions","title":"List of functions","text":"<pre><code>ModCS.Key.Jump(hold) -- Can be set to either Z or X in DoConfig\nModCS.Key.Shoot(hold) -- Can be set to either X or Z in DoConfig\nModCS.Key.Arms(hold) -- A key, Swapping weapons right, swapped if the file \"s_reverse\" exists\nModCS.Key.ArmsRev(hold) -- S key, Swapping weapons left, swapped if the file \"s_reverse\" exists\nModCS.Key.Item(hold) -- Q key, Inventory\nModCS.Key.Map(hold) -- W key, Map System if the player has equip \"2\"\nModCS.Key.Ok(hold) -- Can be either the Jump button or Shoot button in DoConfig\nModCS.Key.Cancel(hold) -- Can be either the Shoot button or Jump button in DoConfig\nModCS.Key.Left(hold) -- Can be either Left arrow key or &lt; in DoConfig\nModCS.Key.Up(hold) -- Can be either Up arrow key or L in DoConfig\nModCS.Key.Right(hold) -- Can be either Right arrow key or ? in DoConfig\nModCS.Key.Down(hold) -- Can be either Down arrow key or &gt; in DoConfig\nModCS.Key.Shift(hold) -- Shift key (Not used by gamepad)\n</code></pre>"},{"location":"api/key/#modcskeygetkey","title":"ModCS.Key.GetKey()","text":"<pre><code>ModCS.Key.GetKey()\n</code></pre> <p>Returns the value of the games <code>gKey</code> value, used to know what keys are being held.</p>"},{"location":"api/key/#modcskeygetkeytrg","title":"ModCS.Key.GetKeyTrg()","text":"<pre><code>ModCS.Key.GetKeyTrg()\n</code></pre> <p>Returns the value of the games <code>gKeyTrg</code> value, used to know what keys are being pressed.</p>"},{"location":"api/key/#modcskeyclearkey","title":"ModCS.Key.ClearKey()","text":"<pre><code>ModCS.Key.ClearKey()\n</code></pre> <p>Clears the value of the games <code>gKey</code> value, setting it to 0.</p>"},{"location":"api/key/#modcskeyclearkeytrg","title":"ModCS.Key.ClearKeyTrg()","text":"<pre><code>ModCS.Key.ClearKeyTrg()\n</code></pre> <p>Clears the value of the games <code>gKeyTrg</code> value, setting it to 0.</p>"},{"location":"api/key/#modcskeygettrg","title":"ModCS.Key.GetTrg()","text":"<pre><code>ModCS.Key.GetTrg()\n</code></pre> <p>Run game input functions. Always gets run in the main gameplay loop, opening, and title loops, but should be run if you go out of that in your code.</p>"},{"location":"api/key/#modcskeykeydown","title":"ModCS.Key.KeyDown()","text":"<pre><code>ModCS.Key.KeyDown(kcode, kchar, krepeat)\n</code></pre> <p>Run code when the <code>kcode</code> (Win32 Keyboard Keycode) is pressed, with <code>kchar</code> being the character (if there is one). <code>krepeat</code> is true if its a repeated key press, holding down the key for a decent amount of time.</p>"},{"location":"api/key/#modcskeykeyup","title":"ModCS.Key.KeyUp()","text":"<pre><code>ModCS.Key.KeyUp(kcode, kchar)\n</code></pre> <p>Run code when the <code>kcode</code> (Win32 Keyboard Keycode) is released, with <code>kchar</code> being the character (if there is one).</p>"},{"location":"api/map/","title":"ModCS.Map","text":"<p>The ModCS.Map namespace contains functions related to Maps.</p> <p>Maps are a collection of files stored in the <code>/data/Stage/</code> folder. They are only usuable in-game via a Stage.</p> <p>Maps are composed of 3 types of files:</p> <ul> <li> <p>PXM (PixMap) files - For storing tile placement.</p> </li> <li> <p>PXE (PixEvent or PixEntity) - For storing NPC placement.</p> </li> <li> <p>TSC Files - For storing an individual map's TextScript.</p> </li> </ul>"},{"location":"api/map/#tile-unit","title":"Tile Unit","text":"<p>Map files (TSC included) use Tile Units for coordinates rather than Pixel Units. One Tile Unit is 16x16 Pixel Units.</p>"},{"location":"api/map/#modcsmapgetwidth","title":"ModCS.Map.GetWidth()","text":"<pre><code>ModCS.Map.GetWidth()\n</code></pre> <p>Returns the width in tile units of the current loaded map.</p>"},{"location":"api/map/#modcsmapgetheight","title":"ModCS.Map.GetHeight()","text":"<pre><code>ModCS.Map.GetHeight()\n</code></pre> <p>Returns the height in tile units of the current loaded map.</p>"},{"location":"api/map/#modcsmapgetattribute","title":"ModCS.Map.GetAttribute()","text":"<pre><code>ModCS.Map.GetAttribute(x, y)\n</code></pre> <p>Returns the attribute of the tile at tile unit coordinates <code>x</code> and <code>y</code>.</p>"},{"location":"api/map/#modcsmapchangetile","title":"ModCS.Map.ChangeTile()","text":"<pre><code>ModCS.Map.ChangeTile(no, x, y, smoke)\n</code></pre> <p>Changes the tile at tile unit coordinates <code>x</code> and <code>y</code> of the current map to tile <code>no</code>.</p> <p><code>smoke</code> is an optional parameter and a Boolean. If set to true, spawn smoke NPCs at the position of the changing tile.</p>"},{"location":"api/mod/","title":"ModCS.Mod","text":"<p>The ModCS.Mod namespace contains functions related to customizing releases of mods.</p>"},{"location":"api/mod/#modcsmodsetname","title":"ModCS.Mod.SetName()","text":"<pre><code>ModCS.Mod.SetName(name)\n</code></pre> <p>Sets the window title of the game to <code>name</code>. This function will only work at top-level.</p>"},{"location":"api/mod/#modcsmodsetauthor","title":"ModCS.Mod.SetAuthor()","text":"<pre><code>ModCS.Mod.SetAuthor(name)\n</code></pre> <p>Sets the author of game to <code>name</code>. The author will be displayed in the version window.</p>"},{"location":"api/mod/#modcsmodsetversion","title":"ModCS.Mod.SetVersion()","text":"<pre><code>ModCS.Mod.SetVersion(v1, v2, v3, v4)\n</code></pre> <p>Sets the version of the game to <code>v1</code>.<code>v2</code>.<code>v3</code>.<code>v4</code>. This version will be in the version window.</p>"},{"location":"api/mod/#modcsmodsetopening","title":"ModCS.Mod.SetOpening()","text":"<pre><code>ModCS.Mod.SetOpening(no, eve, wait)\n</code></pre> <p>Use Stage <code>no</code> for the opening sequence (Game Mode 1). <code>eve</code> and <code>wait</code> are optional parameters.</p> <p>If <code>eve</code> is specified Event <code>eve</code> will run once the opening sequence starts, otherwise Event 0 will run.</p> <p>If <code>wait</code> is specified, wait <code>wait</code> ticks during the opening before transferring to the title screen.</p>"},{"location":"api/mod/#modcsmodsetstart","title":"ModCS.Mod.SetStart()","text":"<pre><code>ModCS.Mod.SetStart(no, x, y, eve)\n</code></pre> <p>Sets the default New Game starting point. Parameters are the same as the ModCS.Stage.Transfer() function.</p>"},{"location":"api/mod/#modcsmodsetspikedamage","title":"ModCS.Mod.SetSpikeDamage()","text":"<pre><code>ModCS.Mod.SetSpikeDamage(damage)\n</code></pre> <p>Sets the damage of the Spike tile type (Attribute 0x42) to <code>damage</code>.</p>"},{"location":"api/mod/#modcsmodsetbosshp","title":"ModCS.Mod.SetBossHP()","text":"<pre><code>ModCS.Mod.SetBossHP(no, hp)\n</code></pre> <p>Sets the life of the map boss <code>no</code> to the <code>hp</code> value given. The table for map bosses in vanilla is as such:</p> <pre><code>1: Omega\n2: Balfrog\n3: Monster X\n4: Core\n5: Ironhead\n6: Dragon Sisters\n7: Undead Core\n8: Heavy Press\n9: Ballos Ball (Phase 2)\n10: Ballos Ball (Phase 4)\n</code></pre>"},{"location":"api/mod/#modcsmodsetstartmychar","title":"ModCS.Mod.SetStartMyChar()","text":"<pre><code>ModCS.Mod.SetStartMyChar(life, maxLife, direct)\n</code></pre> <p>Set the starting new-game state of the players current life to <code>life</code>, max life to <code>maxLife</code>, and direction to <code>direct</code>.</p>"},{"location":"api/modcs/","title":"ModCS Object - Basics","text":"<p>All of ModCS's API is contained in the ModCS global namespace.</p>"},{"location":"api/modcs/#modcswritelog","title":"ModCS.WriteLog()","text":"<pre><code>ModCS.WriteLog(text, number1, number2, number3)\n</code></pre> <p>Write given data to a <code>error.log</code> file located in the same directory as the executable.</p> <p>All number parameters are optional, and will be casted to integers.</p>"},{"location":"api/modcs/#modcsputtext","title":"ModCS.PutText()","text":"<pre><code>ModCS.PutText(text, x, y, color, surface)\n</code></pre> <p>Draw given text to screen at coordinates <code>x</code> and <code>y</code>.  <code>color</code> and <code>surface</code> parameters are optional. </p> <p>If a color is not specified the text will have the color <code>255, 255, 254</code> (<code>#FFFFFE</code>).</p> <p>When a surface is specified, ModCS.PutText will draw to given surface instead.</p>"},{"location":"api/modcs/#modcsputnumber","title":"ModCS.PutNumber()","text":"<pre><code>ModCS.PutNumber(number, x, y, zero, surface)\n</code></pre> <p>Draw given number to screen at coordinates <code>x</code> and <code>y</code>.  <code>zero</code> and <code>surface</code> parameters are optional. </p> <p>Number parameters over 9999 will display capped.</p> <p><code>zero</code> is a Boolean. If set to true a zero will be shown to the left of the number. This only applies to one-digit numbers.</p> <p>When a surface is specified, ModCS.PutNumber will draw to given surface instead.</p>"},{"location":"api/modcs/#modcsgetfullrect","title":"ModCS.GetFullRect()","text":"<p>Returns a full ModCS.Rect. This rect will usually equal to this: <pre><code>{\n    left = 0,\n    top = 0,\n    right = 320,\n    bottom = 240\n}\n</code></pre></p>"},{"location":"api/modcs/#modcsgetgamerect","title":"ModCS.GetGameRect()","text":"<p>Returns the canvas ModCS.Rect of the game. This rect will usually equal to this: <pre><code>{\n    left = 0,\n    top = 0,\n    right = 320,\n    bottom = 240\n}\n</code></pre> During the credits sequence the rect's <code>left</code> value will equal to 160.</p> <p>Note</p> <p>The main difference between ModCS.GetGameRect() and ModCS.GetFullRect() is how both values are used in the original game itself. The full Rect is often the default view limitng value for drawing a bitmap, while the game Rect is the view limiting value for game related objects (NPCs, player, map tiles, etc.). You can use these Rects with ModCS.Rect.PutEx()</p>"},{"location":"api/modcs/#modcsgetdatapath","title":"ModCS.GetDataPath()","text":"<p>Returns the path of the data folder the game is using.</p>"},{"location":"api/modcs/#modcsgetmodulepath","title":"ModCS.GetModulePath()","text":"<p>Returns the path of the folder the games executable is located in.</p>"},{"location":"api/modcs/#modcssetdatapath","title":"ModCS.SetDataPath()","text":"<pre><code>ModCS.SetDataPath(\"NewPathHere\")\n</code></pre> <p>Set the data path of the game to the argument you give it. It is advised to use lua string functions with the Module Path to change the data path.</p>"},{"location":"api/modcs/#modcssetmodulepath","title":"ModCS.SetModulePath()","text":"<pre><code>ModCS.SetModulePath(\"NewPathHere\")\n</code></pre> <p>Set the module path of the game to the argument you give it. It is ill-advised to do this, unless you know what you're doing.</p>"},{"location":"api/modcs/#modcsaddcaret","title":"ModCS.AddCaret()","text":"<pre><code>ModCS.AddCaret(\"MyCaretName\")\n</code></pre> <p>For AutPI compatibility, if you add new carets you should add them using this command first, so other dll mods or scripts dont interfere with what you're doing. This simply adds a blank slot letting the game know its already being used.</p>"},{"location":"api/modcs/#modcsaddentity","title":"ModCS.AddEntity()","text":"<pre><code>ModCS.AddEntity(\"MyEntityName\")\n</code></pre> <p>For AutPI compatibility, if you add new entities you should add them using this command first, so other dll mods or scripts dont interfere with what you're doing. This simply adds a blank slot letting the game know its already being used.</p>"},{"location":"api/modcs/#modcssystemtask","title":"ModCS.SystemTask()","text":"<p>Returns <code>true</code> if the game is currently running tasks, and runs its code.</p> <p>This is for advanced users!</p>"},{"location":"api/modcs/#modcsshutdown","title":"ModCS.ShutDown()","text":"<p>Immediately shutdown the game.</p>"},{"location":"api/modcs/#modcscallescape","title":"ModCS.CallEscape()","text":"<p>Brings up the Escape Menu.</p>"},{"location":"api/modcs/#modcssetmag","title":"ModCS.SetMag()","text":"<pre><code>ModCS.SetMag(number)\n</code></pre> <p>Set the games \"magnification\" factor to a different value. This is how the game decides to resize sprites in different window resolutions and scales them up properly.</p> <pre><code>Magnification 1 = 320x240\nMagnification 2 = 640x480\n</code></pre> <p>This could be useful to advanced users who want to load a larger surface while the game size is higher than magnification 1.</p>"},{"location":"api/modcs/#modcsgetmag","title":"ModCS.GetMag()","text":"<p>Returns the current <code>mag</code> value the game is using.</p>"},{"location":"api/modloader/","title":"ModCS.ModLoader","text":"<p>The ModCS.ModLoader namespace contains functions related to the Cave Story Mod Loader, developed by Clownacy.</p>"},{"location":"api/modloader/#modcsmodloaderwritebyte","title":"ModCS.ModLoader.WriteByte()","text":"<pre><code>ModCS.ModLoader.WriteByte(address, number)\n</code></pre> <p>Replace the byte at <code>address</code> with the <code>number</code> given.</p>"},{"location":"api/modloader/#modcsmodloaderwriteword","title":"ModCS.ModLoader.WriteWord()","text":"<pre><code>ModCS.ModLoader.WriteWord(address, number)\n</code></pre> <p>Replace the word (2 bytes) at <code>address</code> with the <code>number</code> given.</p>"},{"location":"api/modloader/#modcsmodloaderwritelong","title":"ModCS.ModLoader.WriteLong()","text":"<pre><code>ModCS.ModLoader.WriteLong(address, number)\n</code></pre> <p>Replace the long (4 bytes) at <code>address</code> with the <code>number</code> given.</p>"},{"location":"api/modloader/#modcsmodloaderwritewordbe","title":"ModCS.ModLoader.WriteWordBE()","text":"<pre><code>ModCS.ModLoader.WriteWordBE(address, number)\n</code></pre> <p>Replace the word (2 bytes) at <code>address</code> with the <code>number</code> given, in Big Endian format (reversed byte order).</p>"},{"location":"api/modloader/#modcsmodloaderwritelongbe","title":"ModCS.ModLoader.WriteLongBE()","text":"<pre><code>ModCS.ModLoader.WriteLongBE(address, number)\n</code></pre> <p>Replace the long (4 bytes) at <code>address</code> with the <code>number</code> given, in Big Endian format (reversed byte order).</p>"},{"location":"api/modloader/#modcsmodloadergetbyte","title":"ModCS.ModLoader.GetByte()","text":"<pre><code>ModCS.ModLoader.GetByte(address)\n</code></pre> <p>Returns the byte found at <code>address</code>.</p>"},{"location":"api/modloader/#modcsmodloadergetword","title":"ModCS.ModLoader.GetWord()","text":"<pre><code>ModCS.ModLoader.GetWord(address)\n</code></pre> <p>Returns the word found at <code>address</code>.</p>"},{"location":"api/modloader/#modcsmodloadergetlong","title":"ModCS.ModLoader.GetLong()","text":"<pre><code>ModCS.ModLoader.GetLong(address)\n</code></pre> <p>Returns the long found at <code>address</code>.</p>"},{"location":"api/profile/","title":"ModCS.Profile","text":"<p>The ModCS.Mod namespace contains functions related to the save files of mods.</p>"},{"location":"api/profile/#modcsprofilesave","title":"ModCS.Profile.Save()","text":"<pre><code>ModCS.Profile.Save(\"ProfileName.dat\")\n</code></pre> <p>Saves the game when the function is called. The argument is optional, and will save as the standard Profile.dat if there is no string attached.</p>"},{"location":"api/profile/#modcsprofileload","title":"ModCS.Profile.Load()","text":"<pre><code>ModCS.Profile.Load(\"ProfileName.dat\")\n</code></pre> <p>Loads the game when the function is called. The argument is optional, and will load the standard Profile.dat if there is no string attached.</p>"},{"location":"api/profile/#modcsprofileduringsave","title":"ModCS.Profile.DuringSave()","text":"<p>This function is called whenever the game is saved.</p> Example <p>This example will print \"Saving!\" on every save. <pre><code>function ModCS.Profile.DuringSave()\n    print(\"Saving!\")\nend\n</code></pre></p>"},{"location":"api/profile/#modcsprofileduringload","title":"ModCS.Profile.DuringLoad()","text":"<p>This function is called whenever the game is loaded.</p> Example <p>This example will print \"Loading!\" on every load. <pre><code>function ModCS.Profile.DuringLoad()\n    print(\"Loading!\")\nend\n</code></pre></p>"},{"location":"api/stage/","title":"ModCS.Stage","text":"<p>The ModCS.Stage namespace contains functions related to Stages.</p>"},{"location":"api/stage/#stage-table","title":"Stage Table","text":"<p>The stage table is where all of the game's stages are defined. A stage table entry has the following values:</p> Value Usage Map Filename The filename used for loading map and TSC files. Stage Name The name of the stage that will be shown in the minimap and in <code>&lt;MNA</code>. Tileset The filename used for loading the tileset bitmap and PXA file. NPC Sheet 1 Filename The filename used for loading a bitmap to the NPC Spritesheet 1 surface. NPC Sheet 2 Filename The filename used for loading a bitmap to the NPC Spritesheet 2 surface. Background Filename The filename used for loading a bitmap to the Background surface. Background Scroll Type A number which represents how the background will act. Boss Number i am being forced to write these docs please send help <p>The Stage Table is stored in a <code>stage.tbl</code> file that can be found in the <code>data</code> folder. Usually Cave Story map editors heavily depend on the Stage Table to load the correct tilesets, backgrounds and NPC Sheets when the user wants to edit a map. Most editors also do not allow you to edit maps which do not have a defined stage.</p> <p>Note</p> <p>In the original game the Stage Table is not stored in a seperate file but hardcoded into the game executable instead.</p>"},{"location":"api/stage/#modcsstagetransfer","title":"ModCS.Stage.Transfer()","text":"<pre><code>ModCS.Stage.Transfer(no, x, y, eve)\n</code></pre> <p>Transfer to stage <code>no</code>.</p> <p>If <code>x</code> and <code>y</code> are specified, change the player's tile coordinates to <code>x</code> and <code>y</code>.</p> <p>If <code>eve</code> is specified, run TSC Event <code>eve</code> after transferring to the stage. Run Event 0 otherwise.</p>"},{"location":"api/stage/#modcsstagegetcurrentno","title":"ModCS.Stage.GetCurrentNo()","text":"<pre><code>ModCS.Stage.GetCurrentNo()\n</code></pre> <p>Returns the current stage's number.</p>"},{"location":"api/stage/#modcsstagegetfilename","title":"ModCS.Stage.GetFilename()","text":"<pre><code>ModCS.Stage.GetFilename(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetname","title":"ModCS.Stage.GetName()","text":"<pre><code>ModCS.Stage.GetName(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the stage name value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the stage name value of the current stage.</p>"},{"location":"api/stage/#modcsstagegettileset","title":"ModCS.Stage.GetTileset()","text":"<pre><code>ModCS.Stage.GetTileset(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the tileset filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the tileset filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetnpcsheet1","title":"ModCS.Stage.GetNpcSheet1()","text":"<pre><code>ModCS.Stage.GetNpcSheet1(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the NPC Sheet 1 filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the NPC Sheet 1 filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetnpcsheet2","title":"ModCS.Stage.GetNpcSheet2()","text":"<pre><code>ModCS.Stage.GetNpcSheet1(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the NPC Sheet 2 filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the NPC Sheet 2 filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetbackground","title":"ModCS.Stage.GetBackground()","text":"<pre><code>ModCS.Stage.GetBackground(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the Background filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the Background filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetbackgroundmode","title":"ModCS.Stage.GetBackgroundMode()","text":"<pre><code>ModCS.Stage.GetBackgroundMode(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the Background mode value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the Background mode value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetbossno","title":"ModCS.Stage.GetBossNo()","text":"<pre><code>ModCS.Stage.GetBossNo(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the Boss value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the Boss value of the current stage.</p>"},{"location":"api/stage/#modcsstageloadtable","title":"ModCS.Stage.LoadTable()","text":"<pre><code>ModCS.Stage.LoadTable(\"stage.tbl\")\n</code></pre> <p>Loads a <code>stage.tbl</code> file from the argument given, using that instead of the internal exe table.</p>"},{"location":"api/stage/#modcsstageontransfer","title":"ModCS.Stage.OnTransfer()","text":"<p>This function is called whenever a map is changed, via <code>&lt;TRA</code> or <code>ModCS.Stage.Transfer()</code>.</p> Example <p>This example will print \"Transferring Stage!\" on every map change. <pre><code>function ModCS.Stage.OnTransfer()\n    print(\"Transferring Stage!\")\nend\n</code></pre></p>"},{"location":"api/tsc/","title":"ModCS.Tsc","text":"<p>The ModCS.Tsc namespace contains functions related to TextScript (Also known as T-Script).</p> <p>TextScript is vanilla Cave Story's scripting language. Combined with Flags it's used for textboxes, animations, cutscenes, etc.</p>"},{"location":"api/tsc/#commands","title":"Commands","text":"<p>TextScript's syntax is composed of commands (or \"codes\") that do certain actions. When the TSC parser reaches a <code>&lt;</code> symbol it checks the next 3 symbols and compares them to its list of commands. If no command is found an error will occur.</p> <p>... Here I would put my own TSC command list but I'm currently too lazy. Please refer to your map editor's TSC list or this TXT list instead.</p>"},{"location":"api/tsc/#events","title":"Events","text":"<p>TextScript scripts are seperated into Events, which are runnable sets of actions and text.</p> <p>Events are a defined with a <code>#</code> and 4 following digits, which together represent the Event number. Events are usually ended with <code>&lt;END</code>.</p> Example <p>This is a basic TSC example event which opens a textbox. <pre><code>#0100\n&lt;KEY&lt;MSGHello World&lt;NOD&lt;CLO&lt;END\n</code></pre></p>"},{"location":"api/tsc/#modcstscisrunning","title":"ModCS.Tsc.IsRunning()","text":"<p>Returns true if a TextScript event is running. Returns false otherwise.</p>"},{"location":"api/tsc/#modcstscrun","title":"ModCS.Tsc.Run()","text":"<pre><code>ModCS.Tsc.Run(event)\n</code></pre> <p>Run TextScript Event <code>event</code>.</p> <p>Warning</p> <p>It's recommended to only use <code>ModCS.Tsc.Run()</code> when a TextScript event isn't running.</p> <p>If you want to run a different Event during another Event please use ModCS.Tsc.Jump() instead.</p>"},{"location":"api/tsc/#modcstscjump","title":"ModCS.Tsc.Jump()","text":"<pre><code>ModCS.Tsc.Jump(event)\n</code></pre> <p>Jump to TextScript Event <code>event</code> while another Event is running.</p>"},{"location":"api/tsc/#modcstscwait","title":"ModCS.Tsc.Wait()","text":"<pre><code>ModCS.Tsc.Wait(ticks)\n</code></pre> <p>During a TextScript event, wait <code>ticks</code> ticks before running the next command.</p>"},{"location":"api/tsc/#modcstscgetargument","title":"ModCS.Tsc.GetArgument()","text":"<pre><code>ModCS.Tsc.GetArgument(no)\n</code></pre> <p>During a custom TextScript command, get the <code>no</code> argument of the running command. Calling this function will also 'skip' the argument from the TSC parser.</p>"},{"location":"api/tsc/#modcstscgetstring","title":"ModCS.Tsc.GetString()","text":"<pre><code>ModCS.Tsc.GetString(\"String\")\n</code></pre> <p>During a custom TextScript command, get the <code>string</code> argument of the running command. Calling this function will also 'skip' the argument from the TSC parser.</p> Example <p>This is an example of a string used in tsc, if we had 1 string argument and wanted to use \"Test\" as our string in the TSC: <pre><code>&lt;STRTest$\n</code></pre></p>"},{"location":"api/tsc/#custom-commands","title":"Custom Commands","text":"<p>ModCS allows you to overwrite TextScript commands and to have custom ones as well. If a function <code>ModCS.Tsc.Command.XXX</code> is defined (where XXX is the custom command) the function will run when the TextScript parser reaches command <code>&lt;XXX</code>.</p> Example <p>This is an example function for a TextScript command that will print its first argument to the debug console. <pre><code>function ModCS.Tsc.Command.FOO()\n    local no = ModCS.Tsc.GetArgument(1) -- Get the first argument of the running command\n    print(no)\nend\n</code></pre></p> <pre><code>#0100\n&lt;FOO0002&lt;END\n</code></pre> <p>Console output: <pre><code>2\n</code></pre></p>"},{"location":"api/drawing/color/","title":"ModCS.Color","text":"<p>The ModCS.Color class represents colors. They are stored in a RGB format.</p> <p>A ModCS.Color is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>red</code> Number (Casted to integer) Red value of an RGB color (0-255). <code>green</code> Number (Casted to integer) Green value of an RGB color (0-255). <code>blue</code> Number (Casted to integer) Blue value of an RGB color (0-255)."},{"location":"api/drawing/color/#modcscolorcreate","title":"ModCS.Color.Create()","text":"<pre><code>ModCS.Color.Create(red, green, blue)\n</code></pre> <p>Returns a ModCS.Color.</p> <p>All parameters are optional. If any parameters are given, the returned ModCS.Color will use those parameters as RGB values.</p>"},{"location":"api/drawing/color/#modcscolorset","title":"ModCS.Color.Set()","text":"<pre><code>ModCS.Color.Set(color, red, green, blue)\n</code></pre> <p>Sets the ModCS.Color given in the <code>color</code> parameter to a ModCS.Color with the following parameters.</p>"},{"location":"api/drawing/color/#modcscolorbox","title":"ModCS.Color.Box()","text":"<pre><code>ModCS.Color.Box(color, x, y, width, height, surface)\nModCS.Color.Box(color, rect, surface)\n</code></pre> <p>Draw a colored box to the screen at coordinates <code>x</code> and <code>y</code> with width <code>width</code> and height <code>height</code>.</p> <p>The <code>surface</code> parameter is optional. If it's specified, draw a colored box to surface with ID <code>surface</code> instead.</p> <p>Note</p> <p>For a more traditional CortBox usage you may specify a <code>rect</code> instead of coordinates and size.</p>"},{"location":"api/drawing/rect/","title":"ModCS.Rect","text":"<p>The ModCS.Rect class represents Rects. They are a collection of pixel coordinates on a Surface which represent a part of the surface. They are mostly used for displaying different sprites from a spritesheet.</p> <p>A ModCS.Rect is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>left</code> Number (Casted to integer) X coordinate of the upper-left corner of the Rect. <code>top</code> Number (Casted to integer) Y coordinate of the upper-left corner of the Rect. <code>right</code> Number (Casted to integer) X coordinate of the down-right corner of the Rect. <code>bottom</code> Number (Casted to integer) Y coordinate of the down-right corner of the Rect. Rect Example <p>This example shows you how to get the Rect of the number 4 sprite from TextBox.bmp</p> <p></p> <p>The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore, the Rect of the number 4 sprite is:</p> <pre><code>{\n    left = 32,\n    top = 56,\n    right = 40,\n    bottom = 64\n}\n</code></pre>"},{"location":"api/drawing/rect/#modcsrectcreate","title":"ModCS.Rect.Create()","text":"<pre><code>ModCS.Rect.Create(left, top, right, bottom)\n</code></pre> <p>Returns a ModCS.Rect.</p> <p>All parameters are optional. If any parameters are given, the returned ModCS.Rect will use those parameters as Rect values.</p>"},{"location":"api/drawing/rect/#modcsrectset","title":"ModCS.Rect.Set()","text":"<pre><code>ModCS.Rect.Set(rect, left, top, right, bottom)\n</code></pre> <p>Sets the ModCS.Rect given in the <code>rect</code> parameter to a ModCS.Rect with the following parameters.</p>"},{"location":"api/drawing/rect/#modcsrectput","title":"ModCS.Rect.Put()","text":"<pre><code>ModCS.Rect.Put(rect, x, y, surface, alpha)\nModCS.Rect.Put(rect, x, y, surface, surfaceto)\n</code></pre> <p>Draw the given Rect from the surface with ID <code>surface</code> to the screen with coordinates <code>x</code> and <code>y</code>.</p> <p>The <code>alpha</code> parameter is optional and is a Boolean. If set to false the game will draw the rect without removing any fully black pixels. The default value is true.</p> <p>The <code>surfaceto</code> parameter is optional and is a number. If set the game will draw the rect to the surface with ID <code>surfaceto</code>.</p> <p>Note</p> <p>For a more traditional PutBitmap usage you may use ModCS.Rect.PutEx().</p>"},{"location":"api/drawing/rect/#modcsrectputex","title":"ModCS.Rect.PutEx()","text":"<pre><code>ModCS.Rect.PutEx(rect, viewrect, x, y, surface, alpha)\n</code></pre> <p>The same as ModCS.Rect.Put() but with a <code>viewrect</code> which limits the view.</p>"},{"location":"api/drawing/surface/","title":"ModCS.Surface","text":"<p>The ModCS.Surface class represents drawing surfaces. Surfaces are image data types which contain pixels of an image.</p>"},{"location":"api/drawing/surface/#surface-id-table","title":"Surface ID Table","text":"<p>Surfaces are represented by an ID. This table contains all vanilla game surfaces.</p> Value Description Additional Info 0 Title screen This surface is created from the bitmap file <code>/data/Title.bmp</code>. 1 Studio Pixel logo This surface is created from the bitmap file <code>/data/pixel.bmp</code>. 2 Level tileset This surface is used by the game to draw tiles. The game loads the tileset bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 256x256. 6 Fade effect This surface is created from the bitmap file <code>/data/Fade.bmp</code>. 7 HUD This surface is exclusive to ModCS. The game draws all HUD elements to this surface. 8 Items This surface is created from the bitmap file <code>/data/ItemImage.bmp</code>. 9 Minimap This surface is used by the game to draw the Minimap. Its size is 320x240. 10 Screenshot This surface is used by the game to display game loops in other game loops. For example, when the player enters the inventory screen, the game screenshots itself and draws this screenshot to this surface. When the inventory screen is drawn the game first draws the screenshot surface as a background and then draws the inventory screen itself. This surface's size is 320x240. 11 Arms This surface is created from the bitmap file <code>/data/Arms.bmp</code>. 12 Arms Image This surface is created from the bitmap file <code>/data/ArmsImage.bmp</code>. 13 Room name This surface is used by the game for drawing the room name to. This surface's size is 160x16. 14 Stage item This surface is created from the bitmap file <code>/data/StageImage.bmp</code>. 15 Loading This surface is created from the bitmap file <code>/data/Loading.bmp</code>. 16 Player This surface is created from the bitmap file <code>/data/MyChar.bmp</code>. 17 Bullet This surface is created from the bitmap file <code>/data/Bullet.bmp</code>. 19 Caret This surface is created from the bitmap file <code>/data/Caret.bmp</code>. 20 NPC System This surface is created from the bitmap file <code>/data/Npc/NpcSym.bmp</code>. 21 NPC Spritesheet 1 The game loads the NPC Spritesheet 1 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 22 NPC Spritesheet 2 The game loads the NPC Spritesheet 2 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 23 NPC Regular This surface is created from the bitmap file <code>/data/Npc/NpcRegu.bmp</code>. 26 Textbox This surface is created from the bitmap file <code>/data/TextBox.bmp</code>. 27 Face This surface is created from the bitmap file <code>/data/Face.bmp</code>. 28 Level background The game loads the Background bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 29 Value view The game draws damage and XP indicators to this surface. This surface's size is 40x240. 30-34 Text line surfaces from 1 to 5 These surfaces are used by the game for drawing TSC text to. These surfaces are only initialized when TSC starts. Their size is 216x16. The game needs 5 of these for the text scrolling effect. 35 Credits text This surface is used by the game for drawing the credits text to. Its height varies on the credits TSC, but its width is 320. 36 Credits image This surface is created from the bitmap file <code>/data/Credits/Credit01.bmp</code>. It can be swapped with other <code>Credit</code> bitmaps during the credits TSC. 37 Casts This surface is created from the bitmap file <code>/data/Npc/casts.bmp</code> when the credits start. <p>Note</p> <p>In the original game, more than 40 surfaces could not be created. In ModCS this number has been increased to 50 to allow for more custom surfaces.</p>"},{"location":"api/drawing/surface/#modcssurfacecreate","title":"ModCS.Surface.Create()","text":"<pre><code>ModCS.Surface.Create(id, width, height)\nModCS.Surface.Create(id, path)\n</code></pre> <p>Create a surface. Returns a ModCS.Surface which contains the ID of the surface.</p> <p>If <code>width</code> and <code>height</code> are specified, create a generic surface with those sizes.</p> <p>If a <code>path</code> is specified, create a surface with the bitmap given in that path. The path's root is always the game's data folder. Do not add a <code>.bmp</code> file extension to the path. Surfaces created from bitmap files use the specified bitmap file's size.</p> Example <p>This example will create two surfaces, one basic and one from a file. <pre><code>BarSurface = ModCS.Surface.Create(41, 320, 240) -- Create a surface with ID 41 with size 320x240\nFooSurface = ModCS.Surface.Create(42, \"Foo\") -- Create a surface with ID 42 using /data/Foo.bmp\n</code></pre></p> <p>Note</p> <p>When creating custom surfaces, it's reccomended to use surface IDs over 40, as it's possible in the future for ModCS to add new custom surfaces below this number.</p>"},{"location":"api/drawing/surface/#modcssurfaceloadbitmap","title":"ModCS.Surface.LoadBitmap()","text":"<pre><code>ModCS.Surface.LoadBitmap(id, path)\n</code></pre> <p>Draw the bitmap file specified in <code>path</code> to a surface with ID <code>id</code>. The path's root is always the game's data folder. Do not add a <code>.bmp</code> file extension to the path.</p>"},{"location":"api/drawing/surface/#modcssurfacescreenshot","title":"ModCS.Surface.Screenshot()","text":"<pre><code>ModCS.Surface.Screenshot(id, rect)\n</code></pre> <p>Draw a screenshot of the current state of the game to Surface with ID <code>id</code>.</p> <p><code>rect</code> is an optional parameter. If specified only <code>rect</code> of the screen will be drawn to the Surface. </p>"},{"location":"api/flags/flag/","title":"ModCS.Flag","text":"<p>The ModCS.Flag namespace contains functions related to Flags.</p> <p>Flags are in-game \"switches\" that are used to record the player's progress, and are saved to the save file when the player saves the game. The maximum flag is 8000.</p>"},{"location":"api/flags/flag/#hardcoded-flags","title":"Hardcoded flags","text":"<p>There are two flags that change game properties outside of TSC:</p> <ul> <li> <p>If flag <code>4000</code> is set, when the player drowns, instead of the normal drown event, event 1100 will start. This is used in the vanilla game for the after Core boss cutscene.</p> </li> <li> <p>If flag <code>563</code> is not set, the Curly AI NPC will not shoot bullets. (Citation needed)</p> </li> </ul>"},{"location":"api/flags/flag/#modcsflagset","title":"ModCS.Flag.Set()","text":"<pre><code>ModCS.Flag.Set(no)\n</code></pre> <p>Sets (Or \"Switches on\") the flag <code>no</code>.</p>"},{"location":"api/flags/flag/#modcsflagunset","title":"ModCS.Flag.Unset()","text":"<pre><code>ModCS.Flag.UnSet(no)\n</code></pre> <p>Unsets (Or \"Switches off\") the flag <code>no</code>.</p>"},{"location":"api/flags/flag/#modcsflagget","title":"ModCS.Flag.Get()","text":"<pre><code>ModCS.Flag.Get(no)\n</code></pre> <p>Returns true if the flag <code>no</code> is set. Returns false otherwise.</p>"},{"location":"api/flags/skipflag/","title":"ModCS.SkipFlag","text":"<p>The ModCS.SkipFlag namespace contains functions related to Skipflags.</p> <p>Unlike Flags Skipflags do not save to the save file and will reset if the player closes the game. They are used if the player dies after viewing a long cutscene and would have to rewatch a cutscene if a skipflag was not used for it. The maximum skipflag is 64.</p>"},{"location":"api/flags/skipflag/#modcsskipflagset","title":"ModCS.SkipFlag.Set()","text":"<pre><code>ModCS.SkipFlag.Set(no)\n</code></pre> <p>Sets (Or \"Switches on\") the skipflag <code>no</code>.</p>"},{"location":"api/flags/skipflag/#modcsskipflagunset","title":"ModCS.SkipFlag.Unset()","text":"<pre><code>ModCS.SkipFlag.UnSet(no)\n</code></pre> <p>Unsets (Or \"Switches off\") the skipflag <code>no</code>.</p>"},{"location":"api/flags/skipflag/#modcsskipflagget","title":"ModCS.SkipFlag.Get()","text":"<pre><code>ModCS.SkipFlag.Get(no)\n</code></pre> <p>Returns true if the skipflag <code>no</code> is set. Returns false otherwise.</p>"},{"location":"api/inventory/arms/","title":"ModCS.Arms","text":"<p>The ModCS.Arms class represents weapons that can be accessed from the inventory. The game has enough memory for 8 different weapons to be stored in the inventory.</p> <p>A ModCS.Arms is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>id</code> Number (Casted to integer) Type ID of the weapon. <code>level</code> Number (Casted to integer) The weapon's level. <code>exp</code> Number (Casted to integer) The weapon's exp. Resets to 0 after every level up. <code>ammo</code> Number (Casted to integer) The weapon's current ammo count. <code>max_ammo</code> Number (Casted to integer) The maximum ammo of the weapon. If this is set to 0 the weapon will not have an ammo requirement."},{"location":"api/inventory/arms/#modcsarmsadd","title":"ModCS.Arms.Add()","text":"<pre><code>ModCS.Arms.Add(id, ammo)\n</code></pre> <p>Adds weapon of type <code>id</code> to the inventory. If a weapon of type <code>id</code> exists, update it.</p> <p><code>ammo</code> is an optional parameter. If specified, the added weapon will have maximum <code>ammo</code> ammo count.</p>"},{"location":"api/inventory/arms/#modcsarmsremove","title":"ModCS.Arms.Remove()","text":"<pre><code>ModCS.Arms.Remove(id)\n</code></pre> <p>Removes weapon of type <code>id</code> from the inventory.</p>"},{"location":"api/inventory/arms/#modcsarmsuseammo","title":"ModCS.Arms.UseAmmo()","text":"<pre><code>ModCS.Arms.UseAmmo(no)\n</code></pre> <p><code>no</code> is an optional parameter, if not specified <code>no</code> will be set to 1.</p> <p>Use <code>no</code> amount of ammo from the currently selected weapon. Returns false if the amount of ammo can't be used. Returns true otherwise.</p>"},{"location":"api/inventory/arms/#modcsarmsaddammo","title":"ModCS.Arms.AddAmmo()","text":"<pre><code>ModCS.Arms.AddAmmo(no)\n</code></pre> <p>Adds <code>no</code> amount of ammo to the currently selected weapon.</p>"},{"location":"api/inventory/arms/#modcsarmsswitchnext","title":"ModCS.Arms.SwitchNext()","text":"<pre><code>ModCS.Arms.SwitchNext()\n</code></pre> <p>Switches the currently selected weapon to the next one.</p>"},{"location":"api/inventory/arms/#modcsarmsswitchprev","title":"ModCS.Arms.SwitchPrev()","text":"<pre><code>ModCS.Arms.SwitchPrev()\n</code></pre> <p>Switches the currently selected weapon to the previous one.</p>"},{"location":"api/inventory/arms/#modcsarmsswitchfirst","title":"ModCS.Arms.SwitchFirst()","text":"<pre><code>ModCS.Arms.SwitchFirst()\n</code></pre> <p>Switches the currently selected weapon to the first weapon in the inventory.</p>"},{"location":"api/inventory/arms/#modcsarmsaddexp","title":"ModCS.Arms.AddExp()","text":"<pre><code>ModCS.Arms.AddExp(exp)\n</code></pre> <p>Adds <code>exp</code> amount of XP to the player.</p>"},{"location":"api/inventory/arms/#modcsarmsremoveexp","title":"ModCS.Arms.RemoveExp()","text":"<pre><code>ModCS.Arms.RemoveExp(exp)\n</code></pre> <p>Removes <code>exp</code> amount of XP from the player.</p>"},{"location":"api/inventory/arms/#modcsarmsgetlevels","title":"ModCS.Arms.GetLevels()","text":"<pre><code>ModCS.Arms.GetLevels(id)\n</code></pre> <p>Returns an array of the XP requirements for each level of weapon of type <code>id</code>. These values are read from the <code>data/arms_level.tbl</code> file.</p>"},{"location":"api/inventory/arms/#modcsarmsgetcurrent","title":"ModCS.Arms.GetCurrent()","text":"<pre><code>ModCS.Arms.GetCurrent()\n</code></pre> <p>Returns a ModCS.Arms of the currently selected weapon.</p>"},{"location":"api/inventory/arms/#modcsarmsgetcurrentinvpos","title":"ModCS.Arms.GetCurrentInvPos()","text":"<pre><code>ModCS.Arms.GetCurrentInvPos()\n</code></pre> <p>Returns the inventory position of the currently selected weapon.</p>"},{"location":"api/inventory/arms/#modcsarmsgetbyid","title":"ModCS.Arms.GetByID()","text":"<pre><code>ModCS.Arms.GetByID(id)\n</code></pre> <p>Searched the inventory for a weapon with type ID <code>id</code>. If found, return a ModCS.Arms of that weapon. Otherwise return a nil value.</p>"},{"location":"api/inventory/arms/#modcsarmsgetbyinvpos","title":"ModCS.Arms.GetByInvPos()","text":"<pre><code>ModCS.Arms.GetByInvPos(pos)\n</code></pre> <p>Return a ModCS.Arms of the weapon at inventory position <code>pos</code>.</p>"},{"location":"api/inventory/arms/#weapon-shoot-code","title":"Weapon Shoot Code","text":"<p>The way Cave Story weapons work internally is a certain function runs on loop if the player is currently holding a certain type of weapon. ModCS allows you to override a weapon's shoot code. If a function in the <code>ModCS.Arms.Shoot</code> array is defined with the index <code>X</code> (where <code>X</code> is the Weapon Type ID you want to override) in your Lua script the game will run that function instead of the built-in shoot function.</p> Example <pre><code>ModCS.Arms.Shoot[1] = function()\n    -- ...\nend\n</code></pre>"},{"location":"api/inventory/item/","title":"ModCS.Item","text":"<p>The ModCS.Item class represents non-weapon items that can be accessed from the inventory. The game has enough memory for 32 different items to be stored in the inventory.</p> <p>A ModCS.Item is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>id</code> Number (Casted to integer) Type ID of the item."},{"location":"api/inventory/item/#modcsitemadd","title":"ModCS.Item.Add()","text":"<pre><code>ModCS.Item.Add(id)\n</code></pre> <p>Adds item of type <code>id</code> to the inventory.</p>"},{"location":"api/inventory/item/#modcsitemremove","title":"ModCS.Item.Remove()","text":"<pre><code>ModCS.Item.Remove(id)\n</code></pre> <p>Removes item of type <code>id</code> from the inventory.</p>"},{"location":"api/inventory/item/#modcsitemgetbyid","title":"ModCS.Item.GetByID()","text":"<pre><code>ModCS.Item.GetByID(id)\n</code></pre> <p>Searched the inventory for an item with type ID <code>id</code>. If found, return a ModCS.Item of that item. Otherwise return a nil value.</p>"},{"location":"api/inventory/item/#modcsitemgetbyinvpos","title":"ModCS.Item.GetByInvPos()","text":"<pre><code>ModCS.Item.GetByInvPos(pos)\n</code></pre> <p>Return a ModCS.Item of the item at inventory position <code>pos</code>.</p>"},{"location":"api/objects/bullet/","title":"ModCS.Bullet","text":"<p>The ModCS.Bullet class represents Bullets. Bullets are game objects usually shot by the player to damage Ememy NPCs. Bullets will always damage vulnerable NPCs after being shot. Unlike NPCs Bullets only draw from the Bullet Surface.</p> <p>A ModCS.Bullet is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit X position of the Bullet. <code>y</code> Pixel Unit Y position of the Bullet. <code>xm</code> Pixel Unit X velocity of the Bullet. This value does nothing by itself, but can be used with ModCS.Bullet.Move(). <code>ym</code> Pixel Unit Y velocity of the Bullet. This value does nothing by itself, but can be used with ModCS.Bullet.Move(). <code>tgt_x</code> Pixel Unit Target X value. This variable does nothing by itself. <code>tgt_y</code> Pixel Unit Target Y value. This variable does nothing by itself. <code>id</code> Bullet Type ID ID of the Bullet. <code>life</code> Number (Casted to integer) How many frames the Bullet will stay on screen after hitting an Enemy. <code>life_count</code> Number (Casted to integer) Range of the Bullet. This value does nothing by itself but can be used to determine how long the Bullet will last on screen after being spawned. <code>damage</code> Number (Casted to integer) How much damage the bullet will do to an Enemy for one frame. <code>enemyhit_x</code> Pixel Unit The range of the Bullet's hitbox on the X axis. Affects enemies. <code>enemyhit_y</code> Pixel Unit The range of the Bullet's hitbox on the Y axis. Affects enemies. <code>blockhit_x</code> Pixel Unit The range of the Bullet's hitbox on the X axis. Affects map tiles. <code>blockhit_y</code> Pixel Unit The range of the Bullet's hitbox on the Y axis. Affects map tiles. <code>direct</code> Direction Direction of the Bullet. <code>ani_no</code> Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. <code>ani_wait</code> Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. <code>act_no</code> Number (Casted to integer) Act state value. This variable does nothing by itself, but can be used to switch between act states. <code>act_wait</code> Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. <code>count1</code> Number (Casted to integer) Counter value. This variable does nothing by itself. <code>count2</code> Number (Casted to integer) Counter value. This variable does nothing by itself."},{"location":"api/objects/bullet/#the-bullet-buffer","title":"The Bullet Buffer","text":"<p>Spawned Bullet in Cave Story are stored in a buffer (or list) of 64 entries.</p> <p>When the game spawns Bullet it checks trough the Bullet buffer and finds a spot that's not currently occupied by an alive Bullet and replaces that spot with the Bullet it's spawning. When the Bullet in that spot dies, the spot is freed out for when the game decides to spawn another Bullet again.</p> <p>Warning</p> <p>If you will be using any of the following functions for actively updating an Bullet you will have to actively retrieve the Bullet as well.</p>"},{"location":"api/objects/bullet/#modcsbulletspawn","title":"ModCS.Bullet.Spawn()","text":"<pre><code>ModCS.Bullet.Spawn(bullettype, x, y, direct)\n</code></pre> <p>Spawns a Bullet of Bullet Type <code>bullettype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>.</p> <p><code>direct</code> is an optional parameter and the Direction with which the Bullet will spawn.</p> <p>Returns a ModCS.Bullet of the spawned Bullet. </p>"},{"location":"api/objects/bullet/#modcsbulletgetbybufferindex","title":"ModCS.Bullet.GetByBufferIndex()","text":"<pre><code>ModCS.Bullet.GetByBufferIndex(index)\n</code></pre> <p>Directly gets <code>index</code> Bullet from the Bullet buffer.</p>"},{"location":"api/objects/caret/","title":"ModCS.Caret","text":"<p>The ModCS.Caret class represents Carets. Carets are game objects used for particles. They have no collision and draw over tiles. Unlike NPCs Carets only draw from the Caret Surface.</p> <p>A ModCS.Caret is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit X position of the Caret. <code>y</code> Pixel Unit Y position of the Caret. <code>xm</code> Pixel Unit X velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move(). <code>ym</code> Pixel Unit Y velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move(). <code>id</code> Caret Type ID ID of the Caret. <code>direct</code> Direction Direction of the Caret. This mostly does nothing by itself, but is used by different vanilla Carets as a parameter. <code>ani_no</code> Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. <code>ani_wait</code> Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. <code>act_no</code> Number (Casted to integer) Act state value. This variable does nothing by itself, but can be used to switch between act states. <code>act_wait</code> Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. <code>view_x</code> Pixel Unit X offset of the Caret sprite. <code>view_y</code> Pixel Unit Y offset of the Caret sprite."},{"location":"api/objects/caret/#the-caret-buffer","title":"The Caret Buffer","text":"<p>Spawned Carets in Cave Story are stored in a buffer (or list) of 64 entries.</p> <p>When the game spawns Carets it checks trough the Carets buffer and finds a spot that's not currently occupied by an alive Caret and replaces that spot with the Caret it's spawning. When the Caret in that spot dies, the spot is freed out for when the game decides to spawn another Caret again.</p> <p>Warning</p> <p>If you will be using any of the following functions for actively updating an Caret you will have to actively retrieve the Caret as well.</p>"},{"location":"api/objects/caret/#modcscaretspawn","title":"ModCS.Caret.Spawn()","text":"<pre><code>ModCS.Caret.Spawn(carettype, x, y, direct)\n</code></pre> <p>Spawns a Caret of Caret Type <code>carettype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>.</p> <p><code>direct</code> is an optional parameter and the Direction with which the Caret will spawn.</p> <p>Returns a ModCS.Caret of the spawned Caret. </p>"},{"location":"api/objects/caret/#modcscaretgetbybufferindex","title":"ModCS.Caret.GetByBufferIndex()","text":"<pre><code>ModCS.Caret.GetByBufferIndex(index)\n</code></pre> <p>Directly gets <code>index</code> Caret from the Caret buffer.</p>"},{"location":"api/objects/direction/","title":"Direction","text":"<p>Directions in Cave Story are represented by numbers.</p> Value Direction 0 Left 1 Up 2 Right 3 Down 4 Auto <p>Different objects interpret their direction parameter differently, although most of them follow this pattern. The Player and most NPCs only use the left and right directions.</p>"},{"location":"api/objects/npc/","title":"ModCS.Npc","text":"<p>The ModCS.Npc class represents NPCs (Also known as Entities). NPCs are game objects used for enemies, cutscenes, enemy projectiles and (some) bosses. Examples are Toroko, First Cave Critter, Puu Black, etc.</p> <p>A ModCS.Npc is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit X position of the NPC. <code>y</code> Pixel Unit Y position of the NPC. <code>xm</code> Pixel Unit X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move(). <code>ym</code> Pixel Unit Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move(). <code>xm2</code> Pixel Unit Alternative X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2(). <code>ym2</code> Pixel Unit Alternative Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2(). <code>tgt_x</code> Pixel Unit Target X value. This variable does nothing by itself. <code>tgt_y</code> Pixel Unit Target Y value. This variable does nothing by itself. <code>id</code> NPC Type ID ID of the NPC. <code>flag</code> Flag Flag of the NPC. <code>event</code> Event TSC Event of the NPC. <code>surf</code> Surface The surface that the NPC will draw from. <code>hit_voice</code> Sound ID The sound effect that will play when the NPC gets hit. <code>destroy_voice</code> Sound ID The sound effect that will play when the NPC dies. <code>life</code> Number (Casted to integer) The health points of the NPC. <code>damage</code> Number (Casted to integer) The amount of damage the NPC deals to the player upon touching. <code>exp</code> Number (Casted to integer) The XP worth of the NPC. <code>smoke_size</code> Number (Casted to integer) The amount of smoke the NPC will spawn after dying. Can be from 0 to 3 (0 being no smoke being spawned upon death). <code>direct</code> Direction Direction of the NPC. <code>ani_no</code> Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. <code>ani_wait</code> Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. <code>act_no</code> Number (Casted to integer) Act state value. This variable does nothing by itself, but can be changed with the <code>&lt;ANP</code> TSC command. <code>act_wait</code> Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. <code>count1</code> Number (Casted to integer) Counter value. This variable does nothing by itself. <code>count2</code> Number (Casted to integer) Counter value. This variable does nothing by itself. <code>pNpc</code> NPC Parent NPC value."},{"location":"api/objects/npc/#the-npc-buffer","title":"The NPC Buffer","text":"<p>Spawned NPCs in Cave Story are stored in a buffer (or list) of 512 entries. Although the NPC buffer size is 512, the game starts spawning NPCs at different positions in the buffer in different places. Examples include:</p> <ul> <li> <p>NPCs loaded from a PXE file start from 170.</p> </li> <li> <p>NPCs spawned by <code>&lt;SNP</code> start from 256.</p> </li> <li> <p>Water splash entities start from 0.</p> </li> </ul> <p>When the game spawns NPCs it checks trough the NPC buffer and finds a spot that's not currently occupied by an alive NPC and replaces that spot with the NPC it's spawning. When the NPC in that spot dies, the spot is freed out for when the game decides to spawn another NPC again.</p> <p>Warning</p> <p>If you will be using any of the following functions for actively updating an NPC you will have to actively retrieve the NPC as well.</p>"},{"location":"api/objects/npc/#modcsnpcgetbyevent","title":"ModCS.Npc.GetByEvent()","text":"<pre><code>ModCS.Npc.GetByEvent(event)\n</code></pre> <p>Searches the current buffer of spawned NPCs for one with an Event number <code>event</code> and returns a ModCS.Npc of that NPC. Returns a nil otherwise.</p>"},{"location":"api/objects/npc/#modcsnpcspawn","title":"ModCS.Npc.Spawn()","text":"<pre><code>ModCS.Npc.Spawn(npctype, x, y, start_index)\n</code></pre> <p>Spawns an NPC of NPC Type <code>npctype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>. If <code>start_index</code> is specified the NPC buffer start position for the NPC summon will be <code>start_index</code>. Otherwise the NPC buffer start position will be 256.</p> <p>Returns a ModCS.Npc of the spawned NPC. </p>"},{"location":"api/objects/npc/#modcsnpcspawn2","title":"ModCS.Npc.Spawn2()","text":"<pre><code>ModCS.Npc.Spawn2(npctype, x, y, xm, ym, direction, start_index)\n</code></pre> <p>Spawns an NPC of NPC Type <code>npctype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>, with <code>xm</code>, <code>ym</code>, and <code>direction</code> specified. If <code>start_index</code> is specified the NPC buffer start position for the NPC summon will be <code>start_index</code>. Otherwise the NPC buffer start position will be 256.</p> <p>Returns a ModCS.Npc of the spawned NPC. </p>"},{"location":"api/objects/npc/#modcsnpcgetbybufferindex","title":"ModCS.Npc.GetByBufferIndex()","text":"<pre><code>ModCS.Npc.GetByBufferIndex(index)\n</code></pre> <p>Directly gets <code>index</code> NPC from the NPC buffer.</p>"},{"location":"api/objects/pixel/","title":"Pixel Unit","text":"<p>A Pixel Unit represents an in-game space coordinate. While sprites on the screen use screen coordinates, objects such as NPCs, Carets, etc. use pixel units. You may use nonintegral values as pixel units but they will always be rounded to the nearest subpixel (1/512th of a pixel).</p>"},{"location":"api/objects/player/","title":"ModCS.Player","text":"<p>The ModCS.Player global object represents the player (Also known as My Character/ MYC).</p> <p>ModCS.Player is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit The player's X position. <code>y</code> Pixel Unit The player's Y position. <code>tgt_x</code> Number (Casted to integer) The player's camera X focus position. <code>tgt_y</code> Number (Casted to integer) The player's camera Y focus position. <code>index_x</code> Number (Casted to integer) The player's X camera movement from facing direction. <code>index_y</code> Number (Casted to integer) The player's Y camera movement from facing direction. <code>xm</code> Pixel Unit X velocity of the Player. <code>ym</code> Pixel Unit Y velocity of the Player. <code>ani_no</code> Number (Casted to integer) Animation frame value. <code>ani_wait</code> Number (Casted to integer) Animation timer value. <code>direct</code> Direction The player's direction. <code>boost_fuel</code> Number (Casted to integer) The fuel of the Player's Booster. <code>air</code> Number (Casted to integer) Air value of the player. <code>fire_rate</code> Number (Casted to integer) Firerate of the players weapon (\"Rensha\") <code>ammo_empty</code> Number (Casted to integer) Timer of the \"empty\" caret until it vanishes. <code>shock</code> Number (Casted to integer) The players invincibility value. Caps out at 255. <code>splash</code> Number (Casted to integer, BOOL) Set to 1 if the player splashed in water. <code>down</code> Number (Casted to integer, BOOL) Set to 1 if the player is facing down. <code>up</code> Number (Casted to integer, BOOL) Set to 1 if the player is facing up. <code>ques</code> Number (Casted to integer) If 1, a question mark will spawn. <code>boost_sw</code> Number (Casted to integer) The boosters \"direction\". (Could be wrong.) <code>unit</code> Number (Casted to integer) The players \"unit\" value. Used for different movement types."},{"location":"api/objects/player/#modcsplayerishit","title":"ModCS.Player.IsHit()","text":"<pre><code>ModCS.Player.IsHit()\n</code></pre> <p>Returns true if the player is being hit. Returns false otherwise.</p>"},{"location":"api/objects/player/#modcsplayerislookingdown","title":"ModCS.Player.IsLookingDown()","text":"<pre><code>ModCS.Player.IsLookingDown()\n</code></pre> <p>Returns true if the player is looking down. Returns false otherwise.</p>"},{"location":"api/objects/player/#modcsplayerislookingup","title":"ModCS.Player.IsLookingUp()","text":"<pre><code>ModCS.Player.IsLookingUp()\n</code></pre> <p>Returns true if the player is looking up. Returns false otherwise.</p>"},{"location":"api/objects/player/#modcsplayergetlife","title":"ModCS.Player.GetLife()","text":"<pre><code>ModCS.Player.GetLife()\n</code></pre> <p>Returns the player's current life points.</p>"},{"location":"api/objects/player/#modcsplayeraddlife","title":"ModCS.Player.AddLife()","text":"<pre><code>ModCS.Player.AddLife(life)\n</code></pre> <p>Adds <code>life</code> to the player's life points.</p>"},{"location":"api/objects/player/#modcsplayergetmaxlife","title":"ModCS.Player.GetMaxLife()","text":"<pre><code>ModCS.Player.GetMaxLife()\n</code></pre> <p>Returns the player's current maximum life points.</p>"},{"location":"api/objects/player/#modcsplayeraddmaxlife","title":"ModCS.Player.AddMaxLife()","text":"<pre><code>ModCS.Player.AddMaxLife(life)\n</code></pre> <p>Adds <code>life</code> to the player's max life points.</p>"},{"location":"api/objects/player/#modcsplayerdamage","title":"ModCS.Player.Damage()","text":"<pre><code>ModCS.Player.Damage(damage)\n</code></pre> <p>Damages the player by <code>damage</code>.</p>"},{"location":"api/objects/player/#modcsplayersetrect","title":"ModCS.Player.SetRect()","text":"<pre><code>ModCS.Player.SetRect(left, top, right, bottom)\nModCS.Player.SetRect(rect)\n</code></pre> <p>Sets the Rect of the player to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of the player to that Rect instead.</p>"},{"location":"api/objects/player/#modcsplayergetrect","title":"ModCS.Player.GetRect()","text":"<pre><code>ModCS.Player.GetRect()\n</code></pre> <p>Returns the player's Rect.</p>"},{"location":"api/objects/player/#modcsplayeroffsetrect","title":"ModCS.Player.OffsetRect()","text":"<pre><code>ModCS.Player.OffsetRect(left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of the player.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/player/#modcsplayersetviewbox","title":"ModCS.Player.SetViewbox()","text":"<pre><code>ModCS.Player.SetViewbox(front, top, back, bottom)\nModCS.Player.SetViewbox(rangerect)\n</code></pre> <p>Sets the sprite offset of the Player to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the sprite offset of the Player to that RangeRect instead.</p>"},{"location":"api/objects/player/#modcsplayersethitbox","title":"ModCS.Player.SetHitbox()","text":"<pre><code>ModCS.Player.SetHitbox(front, top, back, bottom)\nModCS.Player.SetHitbox(rangerect)\n</code></pre> <p>Sets the hitbox of the Player to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the hitbox of the Player to that RangeRect instead.</p>"},{"location":"api/objects/player/#modcsplayergetviewbox","title":"ModCS.Player.GetViewbox()","text":"<pre><code>ModCS.Player.GetViewbox()\n</code></pre> <p>Returns the sprite offset RangeRect of the player.</p>"},{"location":"api/objects/player/#modcsplayergethitbox","title":"ModCS.Player.GetHitbox()","text":"<pre><code>ModCS.Player.GetHitbox()\n</code></pre> <p>Returns the hitbox RangeRect of the player.</p>"},{"location":"api/objects/player/#modcsplayersetarmsyoffset","title":"ModCS.Player.SetArmsYOffset()","text":"<pre><code>ModCS.Player.SetArmsYOffset(offset)\n</code></pre> <p>Sets the vertical sprite offset of the weapon sprite next to the player to <code>offset</code>.</p>"},{"location":"api/objects/player/#modcsplayerprocessair","title":"ModCS.Player.ProcessAir()","text":"<pre><code>ModCS.Player.ProcessAir()\n</code></pre> <p>Runs the vanilla games \"air processing\" function. This will already get ran if ModCS.Player.unit is 0.</p>"},{"location":"api/objects/range/","title":"ModCS.RangeRect","text":"<p>The ModCS.RangeRect class represents Range Rects (Also known as Other Rects). Unlike Drawing Rects Range Rects are centered rectangles. They are used for things such as NPC hitboxes.</p> <p>A ModCS.Rect is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>front</code> Pixel Unit The radius from the center to the left side of the rectangle. <code>top</code> Pixel Unit The radius from the center to the top side of the rectangle. <code>back</code> Pixel Unit The radius from the center to the right side of the rectangle. <code>bottom</code> Pixel Unit The radius from the center to the bottom side of the rectangle."},{"location":"api/objects/range/#modcsrangerectcreate","title":"ModCS.RangeRect.Create()","text":"<pre><code>ModCS.RangeRect.Create(front, top, back, bottom)\n</code></pre> <p>Returns a ModCS.RangeRect.</p> <p>All parameters are optional. If any parameters are given, the returned ModCS.RangeRect will use those parameters as Range Rect values.</p>"},{"location":"api/objects/range/#modcsrangerectset","title":"ModCS.RangeRect.Set()","text":"<pre><code>ModCS.RangeRect.Set(rect, front, top, back, bottom)\n</code></pre> <p>Sets the ModCS.RangeRect given in the <code>rect</code> parameter to a ModCS.RangeRect with the following parameters.</p>"},{"location":"api/objects/bullet/bits/","title":"Bullet Bits","text":"<p>Bullet Bits (Also known as Bullet Flags) are toggles on Bullets that enable certain Bullet features. They can be turned on for individual Bullet Types.</p> <p>Note</p> <p>In the original game Bullet Bits are bit-wise. Because of this, many editors show bitwise information for them. For simplicity's sake ModCS uses normal decimal values.</p> Value Bitwise Value Usage 2 0x0004 Ignore tile collision. 3 0x0008 Don't vanish when hitting a tile. 4 0x0010 Go trough invincible NPCs. 5 0x0020 Be able to break Snack blocks. 6 0x0040 Go trough Snack blocks."},{"location":"api/objects/bullet/bits/#modcsbulletsetbit","title":"ModCS.Bullet.SetBit()","text":"<pre><code>ModCS.Bullet.SetBit(bul, bit)\n</code></pre> <p>Sets the bit <code>bit</code> for <code>bul</code>.</p>"},{"location":"api/objects/bullet/bits/#modcsbulletunsetbit","title":"ModCS.Bullet.UnsetBit()","text":"<pre><code>ModCS.Npc.UnsetBit(bul, bit)\n</code></pre> <p>Unsets the bit <code>bit</code> for <code>bul</code>.</p>"},{"location":"api/objects/bullet/bits/#modcsbulletcheckbit","title":"ModCS.Bullet.CheckBit()","text":"<pre><code>ModCS.Npc.CheckBit(bul, bit)\n</code></pre> <p>Returns true if the bit <code>bit</code> for <code>bul</code> is set. Returns false otherwise.</p>"},{"location":"api/objects/bullet/collision/","title":"NPC Collision detection","text":""},{"location":"api/objects/bullet/collision/#modcsbullettouchleftwall","title":"ModCS.Bullet.TouchLeftWall()","text":"<pre><code>ModCS.Bullet.TouchLeftWall(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a left wall.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchrightwall","title":"ModCS.Bullet.TouchRightWall()","text":"<pre><code>ModCS.Bullet.TouchRightWall(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a right wall.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchceiling","title":"ModCS.Bullet.TouchCeiling()","text":"<pre><code>ModCS.Bullet.TouchCeiling(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a ceiling.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchfloor","title":"ModCS.Bullet.TouchFloor()","text":"<pre><code>ModCS.Bullet.TouchFloor(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a floor.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchbottomsloperight","title":"ModCS.Bullet.TouchBottomSlopeRight()","text":"<pre><code>ModCS.Bullet.TouchBottomSlopeRight(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a bottom right slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchbottomslopeleft","title":"ModCS.Bullet.TouchBottomSlopeLeft()","text":"<pre><code>ModCS.Bullet.TouchBottomSlopeLeft(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a bottom left slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchtopsloperight","title":"ModCS.Bullet.TouchTopSlopeRight()","text":"<pre><code>ModCS.Bullet.TouchTopSlopeRight(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a top right slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchtopslopeleft","title":"ModCS.Bullet.TouchTopSlopeLeft()","text":"<pre><code>ModCS.Bullet.TouchTopSlopeLeft(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a top left slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchtile","title":"ModCS.Bullet.TouchTile()","text":"<pre><code>ModCS.Bullet.TouchTile(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching any type of collision tile.</p>"},{"location":"api/objects/bullet/functions/","title":"Bullet Manipulation Functions","text":""},{"location":"api/objects/bullet/functions/#modcsbulletsetrect","title":"ModCS.Bullet.SetRect()","text":"<pre><code>ModCS.Bullet.SetRect(bul, left, top, right, bottom)\nModCS.Bullet.SetRect(bul, rect)\n</code></pre> <p>Sets the Rect of <code>bul</code> to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of <code>bul</code> to that Rect instead.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletgetrect","title":"ModCS.Bullet.GetRect()","text":"<pre><code>ModCS.Bullet.GetRect(bul)\n</code></pre> <p>Returns <code>bul</code>'s Rect.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletoffsetrect","title":"ModCS.Bullet.OffsetRect()","text":"<pre><code>ModCS.Bullet.OffsetRect(bul, left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of <code>bul</code>.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletsetviewbox","title":"ModCS.Bullet.SetViewbox()","text":"<pre><code>ModCS.Bullet.SetViewbox(bul, front, top, back, bottom)\nModCS.Bullet.SetViewbox(bul, rangerect)\n</code></pre> <p>Sets the sprite offset of <code>bul</code> to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the sprite offset of <code>bul</code> to that RangeRect instead.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletgetviewbox","title":"ModCS.Bullet.GetViewbox()","text":"<pre><code>ModCS.Bullet.GetViewbox(bul)\n</code></pre> <p>Returns the sprite offset RangeRect of <code>bul</code>.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletactcode","title":"ModCS.Bullet.ActCode()","text":"<pre><code>ModCS.Bullet.ActCode(bul, bultype)\n</code></pre> <p><code>bultype</code> is an optional parameter. If not specified, it will be set to <code>bul</code>'s <code>id</code>.</p> <p>Runs the action code for Bullet Type <code>bultype</code> to <code>bul</code>.</p> <p>Note</p> <p>This will run the vanilla act code for <code>bultype</code>. To run any overwritten act functions, run functions from the <code>ModCS.Bullet.Act</code> array instead. </p>"},{"location":"api/objects/bullet/functions/#modcsbulletdelete","title":"ModCS.Bullet.Delete()","text":"<pre><code>ModCS.Bullet.Delete(bul)\n</code></pre> <p>Deletes <code>bul</code>.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletcountbyid","title":"ModCS.Bullet.CountByID()","text":"<pre><code>ModCS.Bullet.CountByID(id)\n</code></pre> <p>Counts how many Bullets of Bullet Type <code>id</code> are alive on the screen.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletmove","title":"ModCS.Bullet.Move()","text":"<pre><code>ModCS.Bullet.Move(bul)\n</code></pre> <p>Adds <code>xm</code> and <code>ym</code> of <code>bul</code> to <code>bul</code>'s <code>x</code> and <code>y</code>. </p>"},{"location":"api/objects/bullet/id/","title":"Bullet Type IDs","text":"<p>An Bullet Type ID (Also known as Act ID or bullet code) is a number that defines an Bullet's type.</p>"},{"location":"api/objects/bullet/id/#bullet-table","title":"Bullet Table","text":"<p>A table of default Bullet properties are stored in a <code>bullet.tbl</code> file in the data folder. You may edit this table with your favorite Cave Story editor. When Bullets of a set type are spawned they will initially use properties from their Bullet Table entry, although these properties can be changed for Bullets with scripting at any time.</p> <p>Note</p> <p>Some vanilla Bullets change their damage or other features gotten from the Bullet Table dynamically. Changing the Bullet Table properties on these Bullet will most likely have little effect. </p>"},{"location":"api/objects/bullet/id/#bullet-type-reference","title":"Bullet Type reference","text":"Bullet Type ID Bullet 0 Null 1-3 Snake 4-6 Polar Star 7-9 Fireball 10-12 Machine Gun 13-15 Missile Launcher Rocket 16-18 Missile Launcher Explosion 19-21 Bubbline 22 Bubbline Level 3 Thorns 23 Blade Level 3 Slashes 24 Falling Spike (In \"Egg Corridor?\") 25-27 Blade 28-30 Super Missile Launcher Rocket 31-33 Super Missile Launcher Explosion 34-36 Nemesis 37-39 Spur 40-42 Spur Trail 42 Curly's Nemesis 44 Screen Nuke 45 Whimsical Star"},{"location":"api/objects/bullet/id/#overriding-bullets","title":"Overriding Bullets","text":"<p>ModCS allows you to override an Bullet type's act code. If a function in the <code>ModCS.Bullet.Act</code> array is defined with the index <code>X</code> (where <code>X</code> is the Bullet Type ID of the Bullet Type you want to override) in your Lua script the game will run that function instead of the built-in Bullet act code. A ModCS.Bullet will be passed as the first argument of the function when it's called.</p> Example <p>This example will set the Rect of Bullet Type 1 (The Snake Level 1 Bullet) to 16,0,32,16. <pre><code>ModCS.Bullet.Act[0] = function(bul)\n    bul:SetRect(16,0,32,16)\nend\n</code></pre></p>"},{"location":"api/objects/caret/functions/","title":"Caret Manipulation Functions","text":""},{"location":"api/objects/caret/functions/#modcscaretsetrect","title":"ModCS.Caret.SetRect()","text":"<pre><code>ModCS.Caret.SetRect(crt, left, top, right, bottom)\nModCS.Caret.SetRect(crt, rect)\n</code></pre> <p>Sets the Rect of <code>crt</code> to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of <code>crt</code> to that Rect instead.</p>"},{"location":"api/objects/caret/functions/#modcscaretgetrect","title":"ModCS.Caret.GetRect()","text":"<pre><code>ModCS.Caret.GetRect(crt)\n</code></pre> <p>Returns <code>crt</code>'s Rect.</p>"},{"location":"api/objects/caret/functions/#modcscaretoffsetrect","title":"ModCS.Caret.OffsetRect()","text":"<pre><code>ModCS.Caret.OffsetRect(crt, left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of <code>crt</code>.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/caret/functions/#modcscaretactcode","title":"ModCS.Caret.ActCode()","text":"<pre><code>ModCS.Caret.ActCode(crt, carettype)\n</code></pre> <p><code>carettype</code> is an optional parameter. If not specified, it will be set to <code>caret</code>'s <code>id</code>.</p> <p>Runs the action code for Caret Type <code>carettype</code> to <code>crt</code>.</p> <p>Note</p> <p>This will run the vanilla act code for <code>carettype</code>. To run any overwritten act functions, run functions from the <code>ModCS.Caret.Act</code> array instead.  </p>"},{"location":"api/objects/caret/functions/#modcscaretdelete","title":"ModCS.Caret.Delete()","text":"<pre><code>ModCS.Caret.Delete(crt)\n</code></pre> <p>Deletes <code>crt</code>.</p>"},{"location":"api/objects/caret/functions/#modcscaretmove","title":"ModCS.Caret.Move()","text":"<pre><code>ModCS.Caret.Move(crt)\n</code></pre> <p>Adds <code>xm</code> and <code>ym</code> of <code>crt</code> to <code>crt</code>'s <code>x</code> and <code>y</code>. </p>"},{"location":"api/objects/caret/id/","title":"Caret Type IDs","text":"<p>A Caret Type ID (Also known as Act ID or character code) is a number that defines an Caret's type.</p>"},{"location":"api/objects/caret/id/#caret-table","title":"Caret Table","text":"<p>A table of default Caret sprite offsets are stored in a <code>caret.tbl</code> file in the data folder. When Carets of a set type are spawned they will initially use sprite offsets from their Caret Table entry, although these offsets can be changed for Carets with scripting at any time.</p>"},{"location":"api/objects/caret/id/#caret-type-reference","title":"Caret Type reference","text":"Caret Type ID Caret 0 Null 1 Bubble 2 Projectile dissipation 3 Shoot Particle 4 Snake Afterimage (Unused) 5 Zzz Sleeping Particles 6 Snake Afterimage (Duplicate) 7 Booster Particle 8 Drowned Player 9 Interact Question mark 10 'Level Up!' 11 Red hurt particles 12 Explosion flash 13 White circle particles (Used by Demon Crown and when the player bumps onto a ceiling) 14 Broken caret 15 Small projectile dissipation 16 'Empty!' 17 'PUSH JUMP KEY!' (Unused)"},{"location":"api/objects/caret/id/#overriding-carets","title":"Overriding Carets","text":"<p>ModCS allows you to override a Caret type's act code.  If a function in the <code>ModCS.Caret.Act</code> array is defined with the index <code>X</code> (where <code>X</code> is the Caret Type ID of the Caret Type you want to override) in your Lua script the game will run that function instead of the built-in Caret act code. A ModCS.Caret will be passed as the first argument of the function when it's called.</p> Example <p>This example will set the Rect of Caret Type 1 to 0,0,8,8. <pre><code>ModCS.Caret.Act[1] = function(crt)\n    crt:SetRect(0,0,8,8)\nend\n</code></pre></p>"},{"location":"api/objects/npc/bits/","title":"NPC Bits","text":"<p>NPC Bits (Also known as NPC Flags) are toggles on NPCs that enable certain NPC features. They can be turned on for individual NPC Types as well as for individual NPCs in a PXE file.</p> <p>Note</p> <p>In the original game NPC Bits are bit-wise. Because of this, many editors show bitwise information for them. For simplicity's sake ModCS uses normal decimal values.</p> Value Bitwise Value Usage 0 0x0001 Collision against player - Pushes player out. 1 0x0002 Ignore tile attribute 44. 2 0x0004 Cannot be hurt and has a different hit effect when hit by a bullet. 3 0x0008 Ignore tile collision. 4 0x0010 The top of the NPC is bouncy. 5 0x0020 The NPC is shootable. 6 0x0040 Collision against player. 7 0x0080 Rear and top of the NPC does not hurt the player. 8 0x0100 The TSC Event specified in the <code>event</code> parameter of the ModCS.Npc will run when the player touches the NPC. 9 0x0200 The TSC Event specified in the <code>event</code> parameter of the ModCS.Npc will run when the NPC dies. 11 0x0800 The NPC will not spawn unless the Flag specified in the <code>flag</code> parameter of ModCS.Npc is set. 12 0x1000 The NPC will spawn with the <code>direct</code> parameter of the ModCS.Npc being set to 2. 13 0x2000 If the player interacts with the NPC the TSC Event specified in the <code>event</code> parameter of the ModCS.Npc will run. 14 0x4000 The NPC will not spawn if the Flag specified in the <code>flag</code> parameter of ModCS.Npc is set. 15 0x8000 Damage dealt to the NPC will show in a damage indicator."},{"location":"api/objects/npc/bits/#modcsnpcsetbit","title":"ModCS.Npc.SetBit()","text":"<pre><code>ModCS.Npc.SetBit(npc, bit)\n</code></pre> <p>Sets the bit <code>bit</code> for <code>npc</code>.</p>"},{"location":"api/objects/npc/bits/#modcsnpcunsetbit","title":"ModCS.Npc.UnsetBit()","text":"<pre><code>ModCS.Npc.UnsetBit(npc, bit)\n</code></pre> <p>Unsets the bit <code>bit</code> for <code>npc</code>.</p>"},{"location":"api/objects/npc/bits/#modcsnpccheckbit","title":"ModCS.Npc.CheckBit()","text":"<pre><code>ModCS.Npc.CheckBit(npc, bit)\n</code></pre> <p>Returns true if the bit <code>bit</code> for <code>npc</code> is set. Returns false otherwise.</p>"},{"location":"api/objects/npc/collision/","title":"NPC Collision detection","text":""},{"location":"api/objects/npc/collision/#modcsnpctouchleftwall","title":"ModCS.Npc.TouchLeftWall()","text":"<pre><code>ModCS.Npc.TouchLeftWall(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a left wall.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchrightwall","title":"ModCS.Npc.TouchRightWall()","text":"<pre><code>ModCS.Npc.TouchRightWall(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a right wall.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchceiling","title":"ModCS.Npc.TouchCeiling()","text":"<pre><code>ModCS.Npc.TouchCeiling(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a ceiling.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchfloor","title":"ModCS.Npc.TouchFloor()","text":"<pre><code>ModCS.Npc.TouchFloor(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a floor.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchsloperight","title":"ModCS.Npc.TouchSlopeRight()","text":"<pre><code>ModCS.Npc.TouchSlopeRight(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a right slope.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchslopeleft","title":"ModCS.Npc.TouchSlopeLeft()","text":"<pre><code>ModCS.Npc.TouchSlopeLeft(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a left slope.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchtile","title":"ModCS.Npc.TouchTile()","text":"<pre><code>ModCS.Npc.TouchTile(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching any type of collision tile.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchwater","title":"ModCS.Npc.TouchWater()","text":"<pre><code>ModCS.Npc.TouchWater(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching water.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchplayer","title":"ModCS.Npc.TouchPlayer()","text":"<pre><code>ModCS.Npc.TouchPlayer(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching the player.</p>"},{"location":"api/objects/npc/collision/#modcsnpchitflag","title":"ModCS.Npc.HitFlag()","text":"<pre><code>ModCS.Npc.HitFlag(npc, flag)\n</code></pre> <p>Returns true if the <code>npc</code> has the <code>hit_flag</code>, \"<code>flag</code>\" active.</p>"},{"location":"api/objects/npc/functions/","title":"NPC Manipulation Functions","text":""},{"location":"api/objects/npc/functions/#modcsnpcsetrect","title":"ModCS.Npc.SetRect()","text":"<pre><code>ModCS.Npc.SetRect(npc, left, top, right, bottom)\nModCS.Npc.SetRect(npc, rect)\n</code></pre> <p>Sets the Rect of <code>npc</code> to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of <code>npc</code> to that Rect instead.</p>"},{"location":"api/objects/npc/functions/#modcsnpcgetrect","title":"ModCS.Npc.GetRect()","text":"<pre><code>ModCS.Npc.GetRect(npc)\n</code></pre> <p>Returns <code>npc</code>'s Rect.</p>"},{"location":"api/objects/npc/functions/#modcsnpcoffsetrect","title":"ModCS.Npc.OffsetRect()","text":"<pre><code>ModCS.Npc.OffsetRect(npc, left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of <code>npc</code>.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/npc/functions/#modcsnpcsethitbox","title":"ModCS.Npc.SetHitbox()","text":"<pre><code>ModCS.Npc.SetHitbox(npc, front, top, back, bottom)\nModCS.Npc.SetHitbox(npc, rangerect)\n</code></pre> <p>Sets the hitbox of <code>npc</code> to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the hitbox of <code>npc</code> to that RangeRect instead.</p> <p>Warning</p> <p>When editing NPC hitboxes make sure that the front and back values of the hitbox are the same, otherwise you might get weird hitbox behavior.</p>"},{"location":"api/objects/npc/functions/#modcsnpcgethitbox","title":"ModCS.Npc.GetHitbox()","text":"<pre><code>ModCS.Npc.GetHitbox(npc)\n</code></pre> <p>Returns the hitbox RangeRect of <code>npc</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpcsetviewbox","title":"ModCS.Npc.SetViewbox()","text":"<pre><code>ModCS.Npc.SetViewbox(npc, front, top, back, bottom)\nModCS.Npc.SetViewbox(npc, rangerect)\n</code></pre> <p>Sets the sprite offset of <code>npc</code> to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the sprite offset of <code>npc</code> to that RangeRect instead.</p>"},{"location":"api/objects/npc/functions/#modcsnpcgetviewbox","title":"ModCS.Npc.GetViewbox()","text":"<pre><code>ModCS.Npc.GetViewbox(npc)\n</code></pre> <p>Returns the sprite offset RangeRect of <code>npc</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpcactcode","title":"ModCS.Npc.ActCode()","text":"<pre><code>ModCS.Npc.ActCode(npc, npctype)\n</code></pre> <p><code>npctype</code> is an optional parameter. If not specified, it will be set to <code>npc</code>'s <code>id</code>.</p> <p>Runs the action code for NPC Type <code>npctype</code> to <code>npc</code>.</p> <p>Note</p> <p>This will run the vanilla act code for <code>npctype</code>. To run any overwritten act functions, run functions from the <code>ModCS.Npc.Act</code> array instead. </p>"},{"location":"api/objects/npc/functions/#modcsnpcishit","title":"ModCS.Npc.IsHit()","text":"<pre><code>ModCS.Npc.IsHit(npc)\n</code></pre> <p>Returns true if <code>npc</code> is being hit by a bullet. Returns false otherwise.</p>"},{"location":"api/objects/npc/functions/#modcsnpcdelete","title":"ModCS.Npc.Delete()","text":"<pre><code>ModCS.Npc.Delete(npc)\n</code></pre> <p>Deletes <code>npc</code>. Same effect as <code>&lt;DNP</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpckill","title":"ModCS.Npc.Kill()","text":"<pre><code>ModCS.Npc.Kill(npc)\n</code></pre> <p>Kills <code>npc</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpckillonnextframe","title":"ModCS.Npc.KillOnNextFrame()","text":"<pre><code>ModCS.Npc.KillOnNextFrame(npc)\n</code></pre> <p>Sets <code>npc</code> for deletion on the next frame.</p>"},{"location":"api/objects/npc/functions/#modcsnpcmove","title":"ModCS.Npc.Move()","text":"<pre><code>ModCS.Npc.Move(npc)\n</code></pre> <p>Adds <code>xm</code> and <code>ym</code> of <code>npc</code> to <code>npc</code>'s <code>x</code> and <code>y</code>. </p>"},{"location":"api/objects/npc/functions/#modcsnpcmove2","title":"ModCS.Npc.Move2()","text":"<pre><code>ModCS.Npc.Move2(npc)\n</code></pre> <p>Adds <code>xm2</code> and <code>ym2</code> of <code>npc</code> to <code>npc</code>'s <code>x</code> and <code>y</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpcmove3","title":"ModCS.Npc.Move3()","text":"<pre><code>ModCS.Npc.Move3(npc, xv, yv)\n</code></pre> <p>Adds <code>xv</code> and <code>yv</code> from the function argument to <code>npc</code>'s <code>x</code> and <code>y</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpctriggerbox","title":"ModCS.Npc.TriggerBox()","text":"<pre><code>ModCS.Npc.TriggerBox(npc, front, top, back, bottom)\nModCS.Npc.TriggerBox(npc, rangerect)\n</code></pre> <p>Returns true if the player is in a range of a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code> to <code>npc</code>. Returns false otherwise.</p> <p>If a <code>rangerect</code> is specified, set the range used will be the one of the RangeRect instead.</p>"},{"location":"api/objects/npc/id/","title":"NPC Type IDs","text":"<p>An NPC Type ID (Also known as Act ID or character code) is a number that defines an NPC's type.</p>"},{"location":"api/objects/npc/id/#npc-table","title":"NPC Table","text":"<p>A table of default NPC properties are stored in a <code>npc.tbl</code> file in the data folder. You may edit this table with your favorite Cave Story editor. When NPCs of a set type are spawned they will initially use properties from their NPC Table entry, although these properties can be changed for NPCs with scripting at any time.</p> <p>Note</p> <p>Some vanilla NPCs change their damage or other features gotten from the NPC Table dynamically. Changing the NPC Table properties on these NPCs will most likely have little effect. </p> NPC Table parameters on different editors <p>Different Cave Story editors use different terminology on NPC Table parameters. This section translates all of them to ModCS API equivalents.</p> Booster's Lab <p></p> The King's Table <p></p> Cave Editor <p></p> <ol> <li><code>life</code> parameter of a ModCS.Npc</li> <li><code>damage</code> parameter of a ModCS.Npc</li> <li><code>exp</code> parameter of a ModCS.Npc</li> <li>NPC Bits</li> <li>NPC Hitbox</li> <li>NPC Viewbox</li> <li><code>surf</code> parameter of a ModCS.Npc</li> <li><code>hit_voice</code> parameter of a ModCS.Npc</li> <li><code>destroy_voice</code> parameter of a ModCS.Npc</li> <li><code>smoke_size</code> parameter of a ModCS.Npc</li> </ol>"},{"location":"api/objects/npc/id/#npc-type-reference","title":"NPC Type reference","text":"<p>... Here I would put my own NPC Type reference table but I'm currently too lazy. Please refer to your map editor's NPC list or this Cave Story NPC Spreadsheet instead.</p>"},{"location":"api/objects/npc/id/#overriding-npcs","title":"Overriding NPCs","text":"<p>ModCS allows you to override an NPC type's act code. If a function in the <code>ModCS.Npc.Act</code> array is defined with the index <code>X</code> (where <code>X</code> is the NPC Type ID of the NPC Type you want to override) in your Lua script the game will run that function instead of the built-in NPC act code. A ModCS.Npc will be passed as the first argument of the function when it's called.</p> Example <p>This example will set the Rect of NPC Type 0 (The Null NPC) to 16,0,32,16. <pre><code>ModCS.Npc.Act[0] = function(npc)\n    npc:SetRect(16,0,32,16)\nend\n</code></pre></p>"},{"location":"api/objects/player/collision/","title":"Player Collision detection","text":""},{"location":"api/objects/player/collision/#modcsplayertouchleftwall","title":"ModCS.Player.TouchLeftWall()","text":"<pre><code>ModCS.Player.TouchLeftWall()\n</code></pre> <p>Returns true if the player is touching a left wall.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchrightwall","title":"ModCS.Player.TouchRightWall()","text":"<pre><code>ModCS.Player.TouchRightWall()\n</code></pre> <p>Returns true if the player is touching a right wall.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchceiling","title":"ModCS.Player.TouchCeiling()","text":"<pre><code>ModCS.Player.TouchCeiling()\n</code></pre> <p>Returns true if the player is touching a ceiling.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchfloor","title":"ModCS.Player.TouchFloor()","text":"<pre><code>ModCS.Player.TouchFloor()\n</code></pre> <p>Returns true if the player is touching a floor.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchsloperight","title":"ModCS.Player.TouchSlopeRight()","text":"<pre><code>ModCS.Player.TouchSlopeRight()\n</code></pre> <p>Returns true if the player is touching a right slope.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchslopeleft","title":"ModCS.Player.TouchSlopeLeft()","text":"<pre><code>ModCS.Player.TouchSlopeLeft()\n</code></pre> <p>Returns true if the player is touching a left slope.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchtile","title":"ModCS.Player.TouchTile()","text":"<pre><code>ModCS.Player.TouchTile()\n</code></pre> <p>Returns true if the player is touching any type of collision tile.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchwater","title":"ModCS.Player.TouchWater()","text":"<pre><code>ModCS.Player.TouchWater()\n</code></pre> <p>Returns true if the player is touching water.</p>"},{"location":"api/objects/player/collision/#modcsplayerhitflag","title":"ModCS.Player.HitFlag()","text":"<pre><code>ModCS.Player.HitFlag(flag)\n</code></pre> <p>Returns true if the players <code>hit_flag</code> value has the flag specified.</p>"},{"location":"api/objects/player/equip/","title":"Player Equip","text":"<p>Player Equip Values are toggles that enable certain features for the player. They are mostly used in Cave Story for checking equipped items.</p> <p>Note</p> <p>Equip values are bit-wise. This means if you checked for \"3\", that would be like 1 and 2.</p> Value Bitwise Value Usage 0 0x0001 Booster v0.8 (Ignored if v2.0 is equipped) 1 0x0002 Map System 2 0x0004 Arms Barrier 3 0x0008 Turbocharge 4 0x0010 Air Tank 5 0x0020 Booster v2.0 6 0x0040 Mimiga Mask 7 0x0080 Whimsical Star 8 0x0100 Nikumaru Counter"},{"location":"api/objects/player/equip/#modcsplayerequip","title":"ModCS.Player.Equip()","text":"<pre><code>ModCS.Player.Equip(value)\n</code></pre> <p>Sets the equip value <code>value</code>.</p>"},{"location":"api/objects/player/equip/#modcsplayerunequip","title":"ModCS.Player.Unequip()","text":"<pre><code>ModCS.Player.Unequip(value)\n</code></pre> <p>Unsets the equip value <code>value</code>.</p>"},{"location":"api/objects/player/equip/#modcsplayerhasequipped","title":"ModCS.Player.HasEquipped()","text":"<pre><code>ModCS.Player.HasEquipped(value)\n</code></pre> <p>Returns true if the equip value <code>value</code> is set. Returns false otherwise.</p>"},{"location":"api/sound/music/","title":"ModCS.Music","text":"<p>The ModCS.Music namespace contains functions related to playing music.</p>"},{"location":"api/sound/music/#music-id-reference","title":"Music ID reference","text":"Music ID Name Internal Name 0 None XXXX 1 Mischievous Robot WANPAKU 2 Safety ANZEN 3 Game Over GAMEOVER 4 Gravity GRAVITY 5 On To Grasstown WEED 6 Meltdown 2 MDOWN2 7 Eyes of Flame FIREEYE 8 Gestation VIVI 9 Mimiga Town MURA 10 Get Item FANFALE1 11 Balrog's Theme GINSUKE 12 Cemetery CEMETERY 13 Plant PLANT 14 Pulse KODOU 15 Victory FANFALE3 16 Get Life Capsule FANFALE2 17 Tyrant DR 18 Run ESCAPE 19 Jenka 1 JENKA 20 Labyrinth Fight MAZE 21 Access ACCESS 22 Oppression IRONH 23 Geothermal GRAND 24 Cave Story CURLY 25 Moonsong OSIDE 26 Hero's End REQUIEM 27 Scorching Back WANPAK2 28 Quiet QUIET 29 Final Cave LASTCAVE 30 Balcony BALCONY 31 Charge LASTBTL 32 Last Battle LASTBT3 33 The Way Back Home ENDING 34 Zombie ZONBIE 35 Break Down BDOWN 36 Running Hell HELL 37 Jenka 2 JENKA2 38 Living Waterway MARINE 39 Seal Chamber BALLOS 40 Toroko's Theme TOROKO 41 White Stone Wall WHITE"},{"location":"api/sound/music/#modcsmusicplay","title":"ModCS.Music.Play()","text":"<pre><code>ModCS.Music.Play(id)\n</code></pre> <p>Changes the current music playing to music <code>id</code>.</p>"},{"location":"api/sound/music/#modcsmusicgetcurrent","title":"ModCS.Music.GetCurrent()","text":"<pre><code>ModCS.Music.GetCurrent()\n</code></pre> <p>Returns the ID of the current track.</p>"},{"location":"api/sound/music/#modcsmusicgetold","title":"ModCS.Music.GetOld()","text":"<pre><code>ModCS.Music.GetOld()\n</code></pre> <p>Returns the ID of the last track played.</p>"},{"location":"api/sound/music/#modcsmusicgetposition","title":"ModCS.Music.GetPosition()","text":"<pre><code>ModCS.Music.GetPosition()\n</code></pre> <p>Returns the position number of the current track.</p>"},{"location":"api/sound/music/#modcsmusicgetoldposition","title":"ModCS.Music.GetOldPosition()","text":"<pre><code>ModCS.Music.GetOldPosition()\n</code></pre> <p>Returns the position number of the last track played.</p>"},{"location":"api/sound/music/#modcsmusicsetposition","title":"ModCS.Music.SetPosition()","text":"<pre><code>ModCS.Music.SetPosition(x)\n</code></pre> <p>Sets the position number of the current track to <code>x</code>.</p>"},{"location":"api/sound/music/#modcsmusicsetvolume","title":"ModCS.Music.SetVolume()","text":"<pre><code>ModCS.Music.SetVolume(vol)\n</code></pre> <p>Sets the volume of the current track to <code>vol</code>. </p>"},{"location":"api/sound/sound/","title":"ModCS.Sound","text":"<p>The ModCS.Sound namespace contains functions related to playing different sound effects.</p>"},{"location":"api/sound/sound/#sound-effects-id-reference","title":"Sound Effects ID reference","text":"<p>... Here I would put my own sound effects table but I'm currently too lazy. Please refer to your map editor's sound effects list.</p>"},{"location":"api/sound/sound/#modcssoundplay","title":"ModCS.Sound.Play()","text":"<pre><code>ModCS.Sound.Play(id, loop)\n</code></pre> <p>Plays sound effect <code>id</code>.</p> <p><code>loop</code> is an optional parameter and a Boolean. If set to true the given sound effect will play on loop.</p>"},{"location":"api/sound/sound/#modcssoundstop","title":"ModCS.Sound.Stop()","text":"<pre><code>ModCS.Npc.Stop(id)\n</code></pre> <p>Stop playing sound effect <code>id</code>.</p>"},{"location":"api/sound/sound/#modcssoundchangefrequency","title":"ModCS.Sound.ChangeFrequency","text":"<pre><code>ModCS.Sound.ChangeFrequency(id, freq)\n</code></pre> <p>Change the frequency of sound effect <code>id</code> to <code>freq</code>.</p>"},{"location":"api/sound/sound/#modcssoundchangevolume","title":"ModCS.Sound.ChangeVolume","text":"<pre><code>ModCS.Sound.ChangeFrequency(id, volume)\n</code></pre> <p>Change the volume of sound effect <code>id</code> to <code>volume</code>.</p>"},{"location":"api/sound/sound/#modcssoundchangepan","title":"ModCS.Sound.ChangePan","text":"<pre><code>ModCS.Sound.ChangePan(id, pan)\n</code></pre> <p>Change the panning of sound effect <code>id</code> to <code>pan</code>.</p>"},{"location":"guide/basics/","title":"1 - Basics","text":"<p>After you've downloaded ModCS and launched your editor of choice, it's time to start making your mod.</p> <p>To open your mod in an editor go to File -&gt; Load and navigate to your Mod's <code>data</code> folder. There load <code>stage.tbl</code>.</p> <p>Note</p> <p>The King's Table uses a different system for loading mods. You will have to open your <code>stage.tbl</code> file from File -&gt; New. Afterwards, press File -&gt; Save Project to save a The King's Table project file for your mod. Any time you want to load your mod afterwards press File -&gt; Load and open your project file.</p> Loading Different Engines <p>You will have to load different things for different Cave Story engines. For CSE2 Enhanced you may load a <code>mrmap.bin</code>. For Freeware modding you will have to load your mod EXE. If you will be modding freeware it's very important to press File -&gt; Save All right after you have loaded your EXE.</p>"},{"location":"guide/intro/","title":"0 - Introduction","text":"<p>ModCS is a Cave Story modding utility, which's main feature is Lua Scripting.</p> <p>This modding guide will go over the basics of Cave Story modding before going into scripting. Although this guide's main purpose was for ModCS, it will contain extra information about differences in modding between different engines, so if you are new to modding this guide may be a good introduction for any type of engine (Original Freeware EXE, CSE2, etc.) until the Scripting Section, which will exclusively focus on ModCS's Lua Scripting.</p> <p>If you are having any trouble with anything unrelated to Lua scripting there are a couple of places you may ask for help, such as the :material-discord: Cave Story Modding Community or the Cave Story Tribute Site Forums.</p>"},{"location":"guide/lua/","title":"3 - Lua Scripting","text":"<p>The main feature of ModCS is its Lua Scripting API, which allows for advanced Cave Story modifications without the use of Assembly or C. Currently the API has enough features for modifying HUD, advanced modifying of NPCs, making NPCs and custom TSC commands. This chapter of the guide will go over basic usage of the drawing and NPC APIs. By the end of this guide you should be able to:</p> <ul> <li> <p>Make custom HUD elements.</p> </li> <li> <p>Modify sprites of already existing NPCs.</p> </li> <li> <p>Make custom NPCs and enemies from scratch.</p> </li> </ul> <p>Lua is an incredibly easy scripting language to learn and during the course of this guide it's assumed that the reader will be learn it on the go. This is not a general Lua scripting guide, but if you are struggling with keeping up you may want to check out this Lua tutorial.</p>"},{"location":"guide/tsc/","title":"2 - Text Scripting","text":"<p>Text Script (Also known as TSC or T-Script) are the primary way to create and cause things to happen in your stage. TSC's abilities include displaying dialogue, controlling NPCs and making them perform specific actions, giving the player items, or modifying the tiles of your stage on the fly.</p> <p>A typical text script for a stage looks like this:</p> <pre><code>#0101\n&lt;CMD...\n&lt;CMD...\n&lt;CMD...\n&lt;END\n\n#0102\n&lt;CMD...\n&lt;CMD...\n&lt;CMD...\n&lt;END\n\n#0103\n&lt;CMD...\n&lt;CMD...\n&lt;CMD...\n&lt;END\n</code></pre> <p>The preceding # represents a four-digit Event ID, and everything following it are Commands that are run when that particular event occurs, up until the <code>&lt;END</code>.</p> <p>Commands in TSC begin with a <code>&lt;</code> and always have three character names, such as <code>&lt;MSG</code> or <code>&lt;WAI</code>. A TSC command can also have additional numbers following it as parameters that affect its operation, like the following:</p> <pre><code>&lt;AM+0002:0000\n</code></pre> <p>Here, two parameters are passed to the command <code>&lt;AM+</code>: <code>2</code> and <code>0</code>. Parameters are padded with zeros to be exactly four digits long, and are separated by colons. The longest TSC commands can have four parameters, although many have none or only one.</p> <p>In addition to text scripts specific to a given Stage, all Stages automatically share a script contained in <code>data/Head.tsc</code>. In vanilla Cave Story, this contains several events that are used throughout the game, like the \"Do you want to save?\" prompt or \"You have died.\" These always take up the lowest event IDs, so it is generally good practice to start labelling your own events at <code>#0090</code> or <code>#0100</code>.</p>"},{"location":"guide/basics/bgs/","title":"1.4 - Backgrounds","text":"<p>Backgrounds are stored in the <code>data</code> folder as <code>.bmp</code> files with a <code>Bk</code> prefix (Example: <code>BkBlue.bmp</code>). They are choosen per stage therefore are loaded from a Stage Table entry parameter. The other Stage Table entry parameter related to backgrounds is \"Scroll Type\" and it determines the background's scroll type.</p>"},{"location":"guide/basics/npc/","title":"1.5 - NPC Placement","text":"<p>NPCs (Also known as Entities) are in-game objects used for cutscenes and as enemies. NPCs can be stored in maps. Individual map NPC placement is stored in <code>.pxe</code> files that can be found in the <code>data/Stage/</code> folder. NPCs use Tile Unit coordinates when stored in <code>PXE</code> files, but in-game they use Pixel Unit coordinates.</p>"},{"location":"guide/basics/npc/#151-pxe-entry-parameters","title":"1.5.1 - PXE Entry Parameters","text":"<p>Individual entries in <code>PXE</code> files can have unique parameters such as Event ID and Flag ID. These parameters are used with TextScript. Individual entries can also have unique NPC Bits set.</p>"},{"location":"guide/basics/npc/#152-npc-sprites","title":"1.5.2 - NPC Sprites","text":"<p>NPCs' sprites will be taken from specific parts of either the NPC Spritesheet 1 or 2 specified per Stage Table entry or from global spritesheets. From where NPC sprites are taken is usually specified in an NPC type's NPC Table entry.</p>"},{"location":"guide/basics/npctbl/","title":"1.6 - NPC Table","text":"<p>The NPC Table is a table of default properties for each NPC type. It'ss stored in the <code>data/npc.tbl</code> file. Editing the NPC Table can be used to change basic properties such as HP, damage, exp price, hitbox, spritesheet or default bits. Some NPCs dynamically change such values, which would mean that changing these NPCs' NPC Table entry values may have little effect. For such NPCs Scripting should be used instead.</p> <p>Warning</p> <p>When editing NPC hitboxes make sure that the front and back (left and right) values of the hitbox are the same, otherwise you might get weird hitbox behavior.</p>"},{"location":"guide/basics/stage/","title":"1.2 - Stage Table","text":"<p>At this point you are probably wondering \"what is a stage table anyway\".</p> <p>The Stage Table is what Cave Story uses to transfer between different rooms. Usually when the player enters a door that transfers them to another room, the game is saying \"Transfer to Stage Number X\" and data from Stage Table entry No. X is loaded.</p> <p>The Stage Table in ModCS is stored in the <code>stage.tbl</code> file. In the Freeware EXE it's hardcoded into the EXE.</p> <p>You may create, edit and delete Stage Table entries in Cave Story editors.</p> <p>Note</p> <p>Contrary to popular belief making and deleting Stage Table entries in editors such as Booster's Lab  does not create or delete map files. Stage Table entries are just what they are - Some info which points to map files in their \"Filename\" section. The reason people believe deleting Stage Table entries in editors deletes the map files too is because when you click on a Stage Table entry which points to map files that do not eixst, Booster's Lab creates empty map files for you.</p> <p>While you may delete and move Stage Table entries it's important to note that things such as Save Files, the Opening sequence and New Game may break if certain stages end up in the wrong order. Scripting allows you to change the Opening sequence and New Game stages, but more on that in the Scripting section. </p>"},{"location":"guide/basics/tiles/","title":"1.3 - Tile Editing","text":"<p>Tile Editing is the act of placing tiles. It's quite fascinating. Tile placement is stored in <code>.pxm</code> files that can be found in the <code>data/Stage/</code> folder. <code>PXM</code> stands for PixMap.</p>"},{"location":"guide/basics/tiles/#131-tilesets-and-tile-attributes","title":"1.3.1 - Tilesets and Tile attributes","text":"<p>Tilesets are contained in two kinds of files: <code>.bmp</code> files stored in the <code>data/Stage/</code> folder with the prefix <code>Prt</code> (Example: <code>PrtCave.bmp</code>) which store the tileset's bitmap and <code>.pxa</code> files stored in the <code>data/Stage/</code> folder (Example <code>Cave.pxa</code>) which store the tileset's tile attributes.</p> <p>Tile Attributes is a collection of data which represent how certain tiles act in-game (If they are slope tiles, water tiles, etc.).</p> <p>In Booster's Lab you may edit the Attribute of a tile by right clicking it in the Tileset viewer.</p> <p></p> <p>Left clicking on any tile attribute will change it.</p>"},{"location":"guide/basics/tiles/#1311-custom-tilesets","title":"1.3.1.1 - Custom Tilesets","text":"<p>To use a custom tileset simply create a <code>PrtName.bmp</code> in your <code>data/Stage/</code> folder (Where <code>Name</code> is the name of your Tileset). Choosing it in editors' Stage Table entry editor will automatically create an empty <code>.pxa</code> file for you. The game will fail to load Tileset bitmaps over 256x256.</p>"},{"location":"guide/basics/ui/","title":"1.1 - Interface","text":"<p>After you've opened your mod you may double-click on any of the Stages in the side bar to start editing.</p> <p></p> <ol> <li>Stage Table viewer - The sidebar shows the list of Stages in the Stage Table. Double-clicking on any stage here will open it in the Editor Section.</li> <li>Cursor tile coordinates - Shows the Tile Unit coordinates of your cursor.</li> <li>Mode switcher - Lets you change edit modes.</li> <li>Stage tabs - This is where tabs of different stages will be stored. You may close a tab with Ctrl+W.</li> <li>Editor Section - This is where stage editing is mostly done.</li> </ol>"},{"location":"guide/basics/ui/#111-frequently-asked-questions","title":"1.1.1 - Frequently Asked Questions","text":"<p>Q: What's the difference between File-&gt;Save and File-&gt;Save All in Booster's Lab?</p> <p>A: File-&gt;Save only saves edits of the currently opened Stage tab, while File-&gt;Save All saves every map and Stage Table edits.</p>"},{"location":"guide/intro/editors/","title":"0.2 - Installing an Editor","text":"<p>To mod Cave Story you will need a visual editor for property tables, maps, etc. Cave Story Map Editors usually contain all the tools you would need at once.</p> <p>There are 3 editors the community still actively uses and 2 editors which can be used with ModCS.</p>"},{"location":"guide/intro/editors/#021-boosters-lab-recommended","title":"0.2.1 - Booster's Lab (Recommended)","text":"Pros Cons Designed for low-end PCs. Still maintained but not very actively updated. Works on any OS which Java supports. May be buggy and glitchy at times. The most supported by the community editor. Confusing UI design. <p>Note</p> <p>Booster's Lab is the editor this guide will mainly focus on. However, you should be able to figure out where different features on different editors are with ease. This guide personally reccomends using Booster's Lab.</p> <p>Download and extract Booster's Lab from here: </p> <p>:material-download: Download Booster's Lab (v0.5.1.1)</p> <p>To launch Booster's Lab, run <code>launch_classic.bat</code>.</p> <p>Warning</p> <p>Absolutely never use <code>launch_layers.bat</code> on your mod. \"Layers Mode\" is experimental and the only thing it will do on a normal mod is 'corrupt' all of its map files.</p>"},{"location":"guide/intro/editors/#022-the-kings-table","title":"0.2.2 The King's Table","text":"Pros Cons Actively updated. Work in progress and experimental editor. Supports a variety of different mod setups. Every map is a separate Window. Doesn't require Java installed. Only officially supported OS is Windows. <p>Download and extract The King's Table from here: </p> <p>:material-download: Download The King's Table</p> <p>To launch The King's Table, run <code>CaveStoryEditor.exe</code>.</p>"},{"location":"guide/intro/editors/#023-cave-editor","title":"0.2.3 Cave Editor","text":"<p>There really is not much there to say about Cave Editor. It is heavily outdated and does not support ModCS.</p> <p>:material-download: Download Cave Editor (v0.99d)</p>"},{"location":"guide/intro/install/","title":"0.1 - Installation and getting ready","text":"<p>Now, obviously, you would have to download ModCS.</p> <p>:material-download: Download Latest ModCS</p> <p>The downloaded ZIP will need to be extracted before usage, you can do that with a program like 7-Zip.</p> <p>This download contains:</p> <ul> <li>The ModCS EXE</li> <li>A DoConfig EXE</li> <li>A vanilla <code>data</code> folder containing all vanilla <code>data</code> folder assets, with PBMs renamed to BMPs.</li> <li>Extra files necessary for ModCS to function (<code>data/stage.tbl</code>, <code>data/bullet.tbl</code>, <code>data/caret.tbl</code>, <code>data/music.tbl</code>, <code>data/Scripts/main.lua</code>)</li> </ul>"},{"location":"guide/intro/install/#011-migrating-a-mod-to-modcs","title":"0.1.1 - Migrating a mod to ModCS","text":"<p>If you simply want to switch engines from another engine (Original Freeware EXE, CSE2, etc.) to ModCS then you are probably not willing to start with the vanilla data folder. This section will cover how to migrate from Freeware and from CSE2 Enhanced.</p> <p>Important</p> <p>Please note that this section only focuses on migrating data folders, not modifications to the EXE. Any source code edits or Assembly hacks you wish to migrate will have to be recreated with the Lua scripting API manually. Depending on the edits you wish to migrate this might be an easy process.</p>"},{"location":"guide/intro/install/#0111-migrating-from-freeware","title":"0.1.1.1 - Migrating from Freeware","text":"<p>The following guide will show you how to migrate a Freeware <code>data</code> folder to ModCS.</p> <ol> <li>Make sure all bitmaps in your data folder have a <code>.bmp</code> extension.</li> <li>Create a <code>Scripts</code> folder in <code>data</code> and create an empty <code>main.lua</code> file there. (Make sure you edit the file extension).</li> <li>From a vanilla ModCS install copy the <code>data/bullet.tbl</code> file (Or from a PC Cave Story+ install copy the <code>data/base/bullet.tbl</code> file) to your mod's <code>data</code> folder.</li> <li>From a vanilla ModCS install copy the <code>data/arms_level.tbl</code> file (Or from a PC Cave Story+ install copy the <code>data/base/arms_level.tbl</code> file) to your mod's <code>data</code> folder.</li> <li>From a vanilla ModCS install copy the <code>data/caret.tbl</code> and <code>data/music.tbl</code> files to your mod's <code>data</code> folder.</li> <li>Move all ORG files from Resources to a <code>data/Org</code> folder using Resource Hacker (Make sure they have a <code>.org</code> file extension).</li> <li>Move all Credit bitmaps from Resources to a <code>data/Credits</code> folder using Resource Hacker (Make sure they have a <code>.bmp</code> file extension).</li> <li>Move the PIXEL bitmap from Resources to the <code>data</code> folder using Resource Hacker (Make sure it has a <code>.bmp</code> file extension).</li> <li>Using The King's Table convert your Stage Table to a <code>stage.tbl</code> and place it in your <code>data</code> folder. </li> <li>Replace your mod EXE with the ModCS EXE.</li> </ol>"},{"location":"guide/intro/install/#0112-migrating-from-cse2-enhanced","title":"0.1.1.2 - Migrating from CSE2 Enhanced","text":"<p>The following guide will show you how to migrate a CSE2 Enhanced <code>data</code> folder to ModCS.</p> <p>Note</p> <p>This guide only focuses on the most common CSE2 Enhanced <code>data</code> folder format. (.png files + mrmap.bin). For anything else, you're on your own.</p> <ol> <li>Replace all transparent pixels in your <code>.png</code> files with pure black pixels (RGB 0, 0, 0; HEX #000000) in an image editing tool.</li> <li>Save them all as 24-bit <code>.bmp</code>s in your image editing tool and delete all of the original <code>.png</code>s. This is done because ModCS does not support the PNG format. </li> <li>Move the <code>data/PixTone</code> folder to somewhere else, as its not used by ModCS.</li> <li>Move all Credit images from <code>data/Resource/BITMAP</code> to <code>data/Credits</code>.</li> <li>Move <code>Pixel.bmp</code> from <code>data/Resource/BITMAP</code> to <code>data</code>.</li> <li>Move all ORG files from <code>data/Resource/ORG</code> to <code>data/Org</code>.</li> <li>Create a <code>Scripts</code> folder in <code>data</code> and create an empty <code>main.lua</code> file there. (Make sure you edit the file extension).</li> <li>From a vanilla ModCS install copy the <code>data/bullet.tbl</code> file (Or from a PC Cave Story+ install copy the <code>data/base/bullet.tbl</code> file) to your mod's <code>data</code> folder.</li> <li>From a vanilla ModCS install copy the <code>data/arms_level.tbl</code> file (Or from a PC Cave Story+ install copy the <code>data/base/arms_level.tbl</code> file) to your mod's <code>data</code> folder.</li> <li>From a vanilla ModCS install copy the <code>data/caret.tbl</code> and <code>data/music.tbl</code> files to your mod's <code>data</code> folder.</li> <li>Using The King's Table convert your <code>data/mrmap.bin</code> file to a <code>stage.tbl</code>. </li> <li>Replace your mod EXE with the ModCS EXE.</li> </ol>"},{"location":"guide/lua/basic/","title":"3.1 - Basics","text":"<p>To get started with Lua scripting you may want to create a blank <code>debug</code> file without a file extension in the same folder as the ModCS <code>EXE</code>. This will enable various debug features and most importantly a debug console, which can be used for printing values to using <code>print()</code>.</p> <p>The main Lua file that is ran when ModCS runs is stored in the <code>data/Scripts/</code> folder as <code>main.lua</code>. Additional files stored in <code>data/Scripts/</code> may be included using <code>require</code>.</p> <p>You may test that <code>main.lua</code> is executing correctly simply by opening it with a text editor and putting a <code>print()</code> with a string or number. <code>print(\"Hello World!\")</code> should print a <code>Hello World!</code> to the debug console once the game is launched.</p>"},{"location":"guide/lua/basic/#311-game-modes","title":"3.1.1 - Game Modes","text":"<p>The main game loop of Cave Story is separated into 3 modes:</p> Value Game mode 1 Opening sequence. 2 Title screen. 3 Action. <p>You can 'get' the number of the current game mode using <code>ModCS.Game.GetMode()</code>.</p> <p>Putting <code>print(ModCS.Game.GetMode())</code> in the <code>main.lua</code> file will print the game mode to the debug console once the game launches. However, this isn't very practical as this <code>print()</code> will only run when the game launches and the game starts with the opening sequence, meaning that the result of the <code>print()</code> will always be <code>1.0</code> being printed to the debug console.</p> <p>To have a piece of code run every time the game switches game modes you can put it in a globally defined <code>ModCS.Game.Init()</code> function.</p> <p>Example</p> <pre><code>-- Define ModCS.Game.Init()\nfunction ModCS.Game.Init()\n    --[[\n    Every time a new game mode starts print\n    \"New game mode started\" and the ID of\n    the game mode\n    --]]\n    print(\"New game mode started: \" .. ModCS.Game.GetMode())\nend\n</code></pre> <p>This should print out <code>New game mode started: 1.0</code>, <code>New game mode started: 2.0</code> or <code>New game mode started: 3.0</code> depending on the initialized game mode.</p>"},{"location":"guide/lua/basic/#312-key-checking-and-modcsgameact","title":"3.1.2 - Key checking and ModCS.Game.Act()","text":"<p>For things you might want to actively check, something that runs once will not be suited. Instead, you might want to put code meant for an active loop into a globally defined <code>ModCS.Game.Act()</code> function.</p> <p>Example</p> <pre><code>-- Define ModCS.Game.Act()\nfunction ModCS.Game.Act()\n    --[[\n    Infinitely print \"This is an active loop\"\n    into the debug console.\n    --]]\n    print(\"This is an active loop\")\nend\n</code></pre> <p>Something you might want to actively check is key presses. You can use functions contained in the ModCS.Key namespace to check for pressed keys.</p> <p>As an example of use of key presses we are going to make the game add 1 to a variable and print that variable to the debug console every time the player presses the Minimap button (W).</p> <p>Example</p> <pre><code>local number = 0 -- Define local variable number\n\nfunction ModCS.Game.Act()\n    if (ModCS.Key.Map()) then -- If map key is pressed...\n        number = number + 1 -- Add 1 to number\n        print(number) -- Print the result\n    end\nend\n</code></pre> <p>The game will now count the number of times the Minimap button (W) has been pressed and print it to the debug console for us.</p>"},{"location":"guide/lua/drawing/","title":"3.2 - Drawing","text":"<p>Drawing is the act of putting a sprite on the screen. When the game draws directly to the screen it does it in a loop. Most of the time drawing directly to the screen in a single will result in the next frame drawing over it.</p> <p>ModCS will run on loop things put in a globally defined <code>ModCS.Game.Draw()</code> function. The difference between <code>ModCS.Game.Act()</code> and <code>ModCS.Game.Draw()</code> is when they're called in-game. <code>ModCS.Game.Act()</code> is ran before anything is drawn on the screen, therefore anything drawn in it will not appear because it will be 'overdrawn' by the things that draw after it. On the other hand <code>ModCS.Game.Draw()</code> runs after everything has been drawn on the screen, and anything drawn on it will appear over everything drawn so far.</p> <p>Note</p> <p>Similarly to <code>ModCS.Game.Act()</code>, <code>ModCS.Game.Draw()</code> only runs during the main game loop.</p> <p>As an example of drawing we will continue off the example number addition code from the previous page. <code>ModCS.PutNumber()</code> will draw a number sprite of a given number to specific screen coordinates.</p> <p>Example</p> <pre><code>local number = 0 -- Define local variable number\n\n\nfunction ModCS.Game.Act()\n    if (ModCS.Key.Map()) then -- If map key is pressed...\n        number = number + 1 -- Add 1 to number\n        print(number) -- Print the result\n    end\nend\n\nfunction ModCS.Game.Draw()\n    ModCS.PutNumber(number, 0, 0) -- Draw the number to the screen\nend\n</code></pre> <p>The two numbers after <code>number</code> represent X and Y coordinates. For example if you wanted to draw the number in the center of the screen you would do <code>ModCS.PutNumber(number, 160, 120)</code> (Please note that <code>ModCS.PutNumber()</code> offsets the coordinates a little so it can contain up to 4 digit numbers. If you would like to experiment with exact coordinates you may use <code>ModCS.PutText</code>).</p>"},{"location":"guide/lua/drawing/#321-surfaces","title":"3.2.1 - Surfaces","text":"<p>Surfaces are image data types which contain pixels of an image. They are used in-game to have sprites drawn from. For example the player sprites are contained in Surface with ID <code>16</code>. Some Surfaces are simply loaded from a <code>.bmp</code> image when the game launches (Surface <code>16</code> is taken from <code>data/MyChar.bmp</code>). Others are more complicated, such as the Tileset Surface (Surface <code>2</code>), which is used by the game to load the tileset <code>.bmp</code> file specified in a Stage Table entry to, and from where any tiles are drawn from.</p> <p>After Surfaces are created their sizes cannot be changed. Surfaces loaded from <code>.bmp</code> files take their sizes from the <code>.bmp</code> files they were created with. Other surfaces have to be created with specified sizes. This is why things such as per-Stage NPC Sheets (Surfaces <code>21</code> and <code>22</code>) are limited to 320x240.</p>"},{"location":"guide/lua/drawing/#322-rects","title":"3.2.2 - Rects","text":"<p>Rects are a pair of X and Y coordinates which represent a part of a Surface. They are usually used for displaying different sprites from a Surface. You may create a Rect variable with <code>ModCS.Rect.Create()</code>.</p> <p>Example</p> <pre><code>local ExampleRect = ModCS.Rect.Create()\n</code></pre> <p>Rect variables contain the following values:</p> Value Usage <code>left</code> X coordinate of the upper-left corner of the Rect. <code>top</code> Y coordinate of the upper-left corner of the Rect. <code>right</code> X coordinate of the down-right corner of the Rect. <code>bottom</code> Y coordinate of the down-right corner of the Rect. <p>As an example we can try to get the Rect of the number 4 sprite from <code>data/TextBox.bmp</code>.</p> <p></p> <p>The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore we may set our Example Rect variable to the Rect of the number 4 like this:</p> <p>Example</p> <pre><code>local ExampleRect = ModCS.Rect.Create()\n\nExampleRect.left = 32\nExampleRect.top = 56\nExampleRect.right = 40\nExampleRect.bottom = 64\n</code></pre> <p>A cleaner way would be using <code>ModCS.Rect.Set()</code>:</p> <p>Example</p> <pre><code>local ExampleRect = ModCS.Rect.Create()\n\nExampleRect:Set(32, 56, 40, 64)\n</code></pre> <p>An even cleaner way would be creating the Rect variable by giving the <code>left</code>, <code>top</code>, <code>right</code> and <code>bottom</code> values straight to <code>ModCS.Rect.Create()</code>:</p> <p>Example</p> <pre><code>local ExampleRect = ModCS.Rect.Create(32, 56, 40, 64)\n</code></pre> <p>Rects can be drawn to the screen using <code>ModCS.Rect.Put()</code>. For example, if we wanted to draw our example rect from earlier to the center of the screen we would do this:</p> <p>Example</p> <pre><code>local ExampleRect = ModCS.Rect.Create(32, 56, 40, 64)\n\nfunction ModCS.Game.Draw()\n    ExampleRect:Put(160, 120, 26)\nend\n</code></pre> <p><code>26</code> is the ID of the Surface we will be drawing from (Surface <code>26</code> is the Surface to where <code>data/TextBox.bmp</code> is loaded to).</p>"},{"location":"guide/lua/npc/","title":"3.3 - NPCs","text":"<p>One of ModCS's Lua API main features is its NPC API. In this section of the guide we will be going over basic NPC editing.</p> <p>To begin editing an NPC Type you simply have to define a function in the <code>ModCS.Npc.Act</code> with an index of the NPC Type ID you would like to edit. This function will run every frame an NPC of this type exists. The first argument given to this function will be the NPC for which this function is running.</p> <p>Using ModCS.Npc.ActCode() you may run vanilla NPC code for the NPC given in the function.</p> <p>Example</p> <pre><code>--[[\nFor every NPC with type 64 (First Cave Critter)\nthis function will run, and the NPC will be\npassed to the function as `npc`\n--]]\nModCS.Npc.Act[64] = function(npc)\n    --[[\n    Run the vanilla game code for NPC ID 64\n    (First Cave Critter) for `npc`\n    --]]\n    npc:ActCode()\nend\n</code></pre> <p>Doing this will now allow us to inject custom code in the code of NPC type 64, which is the First Cave Critter.</p> <p>The First Cave Critter, like many vanilla NPCs, uses Act States to differentiate between how the NPC should act in certain scenarios.</p> <p>Example</p> <pre><code>ModCS.Npc.Act[64] = function(npc)\n    npc:ActCode()\n    print(npc.act_no)\nend\n</code></pre> <p>Using this code while there is a single NPC of type 64 on screen will allow you to find out what different Act States of the NPC do.</p> <p>With this method you can find out the Act States of the First Cave Critter NPC:</p> <ul> <li> <p>Act State 1 - Idle</p> </li> <li> <p>Act State 2 - Jumped</p> </li> <li> <p>Act State 3 - Falling</p> </li> </ul> <p>This information can help us do certain modifications to the NPC in our code. For example, we can make First Cave Critters spawn smoke once they land on the floor after a fall:</p> <p>Example</p> <pre><code>ModCS.Npc.Act[64] = function(npc)\n    if (npc.act_no == 3 and npc:TouchFloor()) then\n        ModCS.Npc.Spawn(4, npc.x, npc.y)\n    end\n\n    npc:ActCode()\nend\n</code></pre>"},{"location":"guide/lua/npc/#331-editing-npc-rects","title":"3.3.1 - Editing NPC Rects","text":"<p>Note</p> <p>This part of the guide is for advanced Rect changing. While it's still recommended to read it, if you simply wish to offset the sprites of an NPC from a spritesheet use ModCS.Npc.OffsetRect().</p> <p>Similarly to Act States, most NPCs also have Animation States. These define what sprite the NPC should be currently using. </p> <p>You can find out Animation States using a similar method as the one for finding out Act States:</p> <p>Example</p> <pre><code>ModCS.Npc.Act[64] = function(npc)\n    npc:ActCode()\n    print(npc.ani_no)\nend\n</code></pre> <ul> <li>Animation State 1- Closed eyes</li> <li>Animation State 2 - Opened eyes</li> <li>Animation State 3 - Jumping</li> </ul> <p>Using this information and <code>ModCS.Npc.SetRect()</code> we can change the Rects of the NPC.</p> <p>Example</p> <pre><code>ModCS.Npc.Act[64] = function(npc)\n    npc:ActCode()\n\n    local rcLeft = {\n        ModCS.Rect.Create(0, 0, 16, 16),\n        ModCS.Rect.Create(16, 0, 32, 16),\n        ModCS.Rect.Create(32, 0, 48, 16)\n    }\n\n    local rcRight = {\n        ModCS.Rect.Create(0, 16, 16, 32),\n        ModCS.Rect.Create(16, 16, 32, 32),\n        ModCS.Rect.Create(32, 16, 48, 32)\n    }\n\n    --[[\n    The game doesn't do flipped sprites\n    automatically, but we can do them\n    ourselves using npc.direct\n    --]]\n    if (npc.direct == 0) then\n        --[[\n        Lua table indexes start at 1 and animation\n        states start at 0, so we add +1 to the table\n        access index\n        --]]\n        npc:SetRect(rcLeft[npc.ani_no+1])\n    elseif (npc.direct == 2) then\n        npc:SetRect(rcRight[npc.ani_no+1])\n    end\nend\n</code></pre> <p>For a better table syntax, you might want to do regular number tables rather than a table with Rect variables:</p> <p>Example</p> <pre><code>ModCS.Npc.Act[64] = function(npc)\n    npc:ActCode()\n\n    local rcLeft = {\n        {0, 0, 16, 16},\n        {16, 0, 32, 16},\n        {32, 0, 48, 16}\n    }\n\n    local rcRight = {\n        {0, 16, 16, 32},\n        {16, 16, 32, 32},\n        {32, 16, 48, 32}\n    }\n\n    if (npc.direct == 0) then\n        npc:SetRect(rcLeft[npc.ani_no+1][1], rcLeft[npc.ani_no+1][2], rcLeft[npc.ani_no+1][3], rcLeft[npc.ani_no+1][4])\n    elseif (npc.direct == 2) then\n        npc:SetRect(rcRight[npc.ani_no+1][1], rcRight[npc.ani_no+1][2], rcRight[npc.ani_no+1][3], rcRight[npc.ani_no+1][4])\n    end\nend\n</code></pre>"},{"location":"guide/lua/npc/#332-making-npcs-from-scratch","title":"3.3.2 - Making NPCs from scratch","text":"<p>NPC Act functions do not have to contain <code>ModCS.Npc.ActCode()</code>, which allows you to create NPC Types entirely from scratch. This can be done in several ways, so this guide won't go over a definitive way to make NPCs. Instead I recommend checking out examples, reading the documentation or reading NPC code of other people.</p>"},{"location":"guide/tsc/box/","title":"2.1 - Making a dialog box appear","text":"<p>The most common use of TSC by far is in making dialog boxes. The most basic text script is:</p> <pre><code>#0100\n&lt;MSGYour text here!&lt;NOD&lt;CLO&lt;END\n</code></pre> <p>A few different commands go into making this script work:</p> <ul> <li><code>&lt;MSG</code> -- make the empty dialog box appear</li> <li><code>&lt;NOD</code> -- wait for the player to press a key before continuing</li> <li><code>&lt;CLO</code> -- close the dialog box</li> </ul> <p>Additionally, note that any non-command text in the script is instead written to the dialog box, provided it is open.</p> <p>Longer dialog will want to use multiple <code>&lt;NOD</code> commands like so:</p> <pre><code>#0100\n&lt;MSGWhen they left, the fans turned\noff permanently.&lt;NOD\nBut recently they started spinning\nagain. I wonder what's making\nthem run...&lt;NOD&lt;CLO\n</code></pre> <p>Even if there are no explicit breaks in the text itself, it is important to place pauses in an ergonomic way. Since only three lines can be properly on screen at any given time,  a well-placed <code>&lt;NOD</code> allows the player to read each set of lines at an appropriate pace.</p> <p>Other commands can be placed in the middle of non-command text, causing them to trigger when that text is displayed:</p> <pre><code>#0100\n&lt;MSGAre you ready for a funny noise?&lt;NOD\nBe&lt;SOU0005eep!&lt;NOD&lt;CLO\n</code></pre> <p>Here, a sound will be played by the <code>&lt;SOU</code> command right in the middle of the word.</p>"},{"location":"guide/tsc/chest/","title":"2.3 - Making a chest","text":""},{"location":"guide/tsc/chest/#231-flags","title":"2.3.1 - Flags","text":"<p>In TSC, flags are the primary way of saving information and performing different commands based on that information. A flag has a number associated with it as an ID, and can either be set to ON or OFF. This status is saved to the player's savefile and persists across all stages.</p> <p>Setting a flag to ON is done with the <code>&lt;FL+</code> command -- e.g. <code>&lt;FL+1000</code> sets flag number <code>1000</code>. Setting a flag to OFF is done with the <code>&lt;FL-</code> command -- e.g. <code>&lt;FL-1000</code> sets flag number <code>1000</code>.</p> <p>Finally, to do different things based on the state of a flag, the <code>&lt;FLJ</code> command is used to jump to different events. For instance:</p> <pre><code>#0100\n&lt;FLJ1000:0101\n&lt;MSGFlag 1000 is not set.&lt;NOD&lt;CLO&lt;END\n\n#0101\n&lt;MSGFlag 1000 is set.&lt;NOD&lt;CLO&lt;END\n</code></pre> <p>If the flag <code>1000</code> is set, then rather than continuing to run the commands in event <code>100</code>, the game will stop and switch to running the commands in event <code>101</code> instead. In total, flags allows you to save permanently when some event occurs, and conditionally split two different possible actions to take into two separate events.</p>"},{"location":"guide/tsc/chest/#232-a-chest-with-a-weapon","title":"2.3.2 - A chest with a weapon","text":"<p>Cave Story does not have a particularly unified item system -- weapons, life capsules, and items all are given to the player through different TSC commands. For a weapon, the <code>&lt;AM+</code> command is used, which takes the weapon ID and the amount of ammo to give (or 0 for infinite) as arguments. A simple event (attached to a Chest NPC) to give the player a Polar Star might look like:</p> <pre><code>#0100\n&lt;PRI&lt;FLJ1000:0101&lt;FL+1000&lt;CNP0200:0021:0000\n&lt;MSGOpened the chest.&lt;NOD&lt;GIT0002&lt;AM+0002:0000&lt;CLR\nGot the =Polar Star=!&lt;WAI0160&lt;NOD&lt;CLO&lt;END\n\n#0101\n&lt;PRI&lt;MSGEmpty.&lt;NOD&lt;CLO&lt;END\n</code></pre> <p>Note the use of the flag <code>1000</code> here. Once the chest is opened for the first time, the flag will be set, and subsequent interactions will instead display \"Empty.\"  A few other new commands:</p> <ul> <li><code>&lt;CNP</code> functions similar to <code>&lt;DNP</code>, but changes the type of the NPC instead. Here we change the associated Chest NPC (#15) to an Opened Chest NPC (#21).</li> <li><code>&lt;GIT</code> displays an image of an item above the textbox, separate from actually giving the item.</li> <li><code>&lt;WAI</code> simply waits the specified number of frames. This is used in vanilla Cave Story to wait for all the sounds to finish playing (although this chest does not include them).</li> </ul> <p>Additionally, your Chest NPC should have flag <code>1000</code> set as its Flag ID. The code for the Chest NPC is set up to switch immediately to being opened if its Flag ID is set, so re-entering the room will leave it open.</p>"},{"location":"guide/tsc/door/","title":"2.2 - Making a door","text":"<p>Doors in Cave Story are made using NPCs that run an event in your text script when interacted with. A basic one can be made by placing a Null NPC and check its Interactable NPC Bit. Then, construct a TSC event like so:</p> <pre><code>#0100\n&lt;PRI&lt;FAO0000&lt;TRAarguments...\n</code></pre> <p>The <code>&lt;PRI</code> command prevents the player (and anything else) from moving, and the <code>&lt;FAO</code> command starts a fade out. The <code>&lt;TRA</code> command is then responsible for moving the player to a new Stage, so its arguments are dependent on where you want to go. It takes the following:</p> <pre><code>&lt;TRAnew stage ID:new event ID:starting x position:starting y position\n</code></pre> <p>So if you wanted to take a player to Stage #2 at position (2, 1), then it might look like</p> <pre><code>#0100\n&lt;PRI&lt;FAO0000&lt;TRA0002:0090:0002:0001&lt;END\n</code></pre> <p>The \"new Event ID\" represents an event in the text script of the new stage, which is crucial: if you don't have some type of event set up in the other stage, then there will be nothing to perform the fade back in after the fade out! For this example, <code>#0090</code> in stage #2 might look like:</p> <pre><code>#0090\n&lt;MNA&lt;CMU0008&lt;FAI0000&lt;END\n</code></pre> <p>Here, <code>&lt;MNA</code> displays the new stage name, and <code>&lt;CMU</code> sets the music track to be played. Then <code>&lt;FAI</code> fades the game back in. Once you have your events set up, you can set the event ID on your NPC to e.g. <code>100</code> to have your script fire on interaction.</p> <p>If you want to make a closed door that visibly opens when interacted with, you can use a Door NPC rather than a Null NPC. Then, you can use the <code>&lt;DNP</code> and <code>&lt;SOU</code> commands in your event:</p> <pre><code>#0100\n&lt;PRI&lt;SOU0011&lt;DNP0100&lt;FAO000&lt;TRA0002:0090:0002:0001&lt;END\n</code></pre> <p>The <code>&lt;SOU</code> command plays sound 11, which the sound of opening a door.</p> <p>The <code>&lt;DNP</code> command deletes NPCs attached to the specified event, thus removing the door when interacted with.</p>"}]}