{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ModCS","text":"<p>This is a new site for the documentation of ModCS, a Cave Story modding lua scripting API. It allows you to make custom hud elements, easily modify and make NPCs, create custom weapons and create custom TextScript commands.</p> <p>This project originally was developed by aikyuu and yasinbread, and the old site for ModCS is now currently out-of-date with the new features that have been added since.</p> <p>The current day of ModCS would not be the same without their hard work, so thank them for the creation of this tool!</p>"},{"location":"options/","title":"Extra Options","text":"<p>Vanilla Cave Story has some extra functionality if certain empty files without file extension are present in the same directory as the EXE.</p>"},{"location":"options/#vanilla-options","title":"Vanilla Options","text":"<ul> <li><code>s_reverse</code> - Swaps the weapon switch keys.</li> <li><code>mute</code> - Unhides a context menu which opens a window for muting different Organya channels.</li> <li><code>fps</code> - Enables a Framerate counter.</li> </ul>"},{"location":"api/camera/","title":"ModCS.Camera","text":"<p>The ModCS.Camera namespace contains functions related to the in-game camera.</p>"},{"location":"api/camera/#modcscamerasettarget","title":"ModCS.Camera.SetTarget()","text":"<pre><code>ModCS.Camera.SetTarget(obj)\n</code></pre> <p>Sets the camera target to Game object <code>obj</code> (Can be ModCS.Player, a ModCS.Npc, a ModCS.Caret or a ModCS.Bullet)</p>"},{"location":"api/camera/#modcscamerasetdelay","title":"ModCS.Camera.SetDelay()","text":"<pre><code>ModCS.Camera.SetDelay(x)\n</code></pre> <p>Sets the camera delay to <code>x</code> (Default is 16).</p>"},{"location":"api/camera/#modcscamerareset","title":"ModCS.Camera.Reset()","text":"<pre><code>ModCS.Camera.Reset()\n</code></pre> <p>Resets the camera position to the player.</p>"},{"location":"api/camera/#modcscameragetxpos","title":"ModCS.Camera.GetXPos()","text":"<pre><code>ModCS.Camera.GetXPos()\n</code></pre> <p>Returns the camera's X axis position in Pixel Units.</p>"},{"location":"api/camera/#modcscameragetypos","title":"ModCS.Camera.GetYPos()","text":"<pre><code>ModCS.Camera.GetYPos()\n</code></pre> <p>Returns the camera's Y axis position in Pixel Units.</p>"},{"location":"api/camera/#modcscamerasetquake","title":"ModCS.Camera.SetQuake()","text":"<pre><code>ModCS.Camera.SetQuake(time)\n</code></pre> <p>Makes the camera shake for <code>time</code> ticks.</p>"},{"location":"api/game/","title":"ModCS.Game","text":"<p>Functions related to the main game loop. Stored in the ModCS.Game object.</p> <p>Warning</p> <p>The main game loop does not include:</p> <ul> <li>The inventory screen</li> <li>The stage select screen</li> <li>Minimap screen</li> <li>Credits</li> <li>Pause screen</li> </ul> <p>Functions such as ModCS.Game.Act() and ModCS.Game.Draw() will not run during these screens.</p>"},{"location":"api/game/#modcsgamegetmode","title":"ModCS.Game.GetMode()","text":"<pre><code>ModCS.Game.GetMode()\n</code></pre> <p>Return a number that represents the current game mode.</p> Value Game mode 1 Opening sequence. 2 Title screen. 3 Action."},{"location":"api/game/#modcsgameisnew","title":"ModCS.Game.IsNew()","text":"<pre><code>ModCS.Game.IsNew()\n</code></pre> <p>Returns true if the 'New' option in the title screen was selected. Returns false otherwise.</p>"},{"location":"api/game/#modcsgameinit","title":"ModCS.Game.Init()","text":"<p>This function is called whenever a game mode is started.</p> Example <p>This example will clear a variable <code>foo</code> on every game mode start. <pre><code>function ModCS.Game.Init()\n    -- Clear our foo variable\n    foo = 0\nend\n</code></pre></p>"},{"location":"api/game/#modcsgamecancontrol","title":"ModCS.Game.CanControl()","text":"<pre><code>ModCS.Game.CanControl()\n</code></pre> <p>Returns false during a <code>&lt;KEY</code> or <code>&lt;PRI</code>. Returns true otherwise.</p>"},{"location":"api/game/#modcsgamecanact","title":"ModCS.Game.CanAct()","text":"<pre><code>ModCS.Game.CanAct()\n</code></pre> <p>Returns false during a <code>&lt;PRI</code>. Returns true otherwise.</p>"},{"location":"api/game/#modcsgameact","title":"ModCS.Game.Act()","text":"<p>This function is called every frame before anything is updated or drawn in the main game loop.</p> Example <p>This example will add 1 to a variable <code>foo</code> every frame. <pre><code>function ModCS.Game.Act()\n    -- Add 1 to our foo variable every frame\n    foo = foo + 1\nend\n</code></pre></p>"},{"location":"api/game/#modcsgameupdate","title":"ModCS.Game.Update()","text":"<p>This function is called every frame before anything is drawn in the main game loop. It differentiates from ModCS.Game.Act only on when exactly it's ran.</p>"},{"location":"api/game/#modcsgamedraw","title":"ModCS.Game.Draw()","text":"<p>This function is called every frame after everything is drawn in the main game loop.</p> Example <p>This example will draw the value of the variable <code>foo</code> using ModCS.PutNumber. <pre><code>function ModCS.Game.Draw()\n    -- Draw the value of our variable\n    ModCS.PutNumber(foo, 0, 0)\nend\n</code></pre></p> <p>Note</p> <p>ModCS.Game.Draw() will draw over everything. If you're planning on using it for custom HUD it's recommended to draw to the custom HUD Surface instead.</p>"},{"location":"api/key/","title":"ModCS.Key","text":"<p>The ModCS.Key namespace contains functions for checking key presses.</p> <p>All ModCS.Key functions follow a similar format:</p> <pre><code>ModCS.Key.Button(hold)\n</code></pre> <p>Returns <code>true</code> if the button is being pressed.</p> <p><code>hold</code> is an optional parameter and a Boolean. If set to <code>true</code> the function will return true if the button is being held.</p>"},{"location":"api/key/#list-of-functions","title":"List of functions","text":"<pre><code>ModCS.Key.Jump(hold) -- Can be set to either Z or X in DoConfig\nModCS.Key.Shoot(hold) -- Can be set to either X or Z in DoConfig\nModCS.Key.Arms(hold) -- A key, Swapping weapons right, swapped if the file \"s_reverse\" exists\nModCS.Key.ArmsRev(hold) -- S key, Swapping weapons left, swapped if the file \"s_reverse\" exists\nModCS.Key.Item(hold) -- Q key, Inventory\nModCS.Key.Map(hold) -- W key, Map System if the player has equip \"2\"\nModCS.Key.Ok(hold) -- Can be either the Jump button or Shoot button in DoConfig\nModCS.Key.Cancel(hold) -- Can be either the Shoot button or Jump button in DoConfig\nModCS.Key.Left(hold) -- Can be either Left arrow key or &lt; in DoConfig\nModCS.Key.Up(hold) -- Can be either Up arrow key or L in DoConfig\nModCS.Key.Right(hold) -- Can be either Right arrow key or ? in DoConfig\nModCS.Key.Down(hold) -- Can be either Down arrow key or &gt; in DoConfig\nModCS.Key.Shift(hold) -- Shift key (Not used by gamepad)\n</code></pre>"},{"location":"api/key/#modcskeygetkey","title":"ModCS.Key.GetKey()","text":"<pre><code>ModCS.Key.GetKey()\n</code></pre> <p>Returns the value of the games <code>gKey</code> value, used to know what keys are being held.</p>"},{"location":"api/key/#modcskeygetkeytrg","title":"ModCS.Key.GetKeyTrg()","text":"<pre><code>ModCS.Key.GetKeyTrg()\n</code></pre> <p>Returns the value of the games <code>gKeyTrg</code> value, used to know what keys are being pressed.</p>"},{"location":"api/key/#modcskeyclearkey","title":"ModCS.Key.ClearKey()","text":"<pre><code>ModCS.Key.ClearKey()\n</code></pre> <p>Clears the value of the games <code>gKey</code> value, setting it to 0.</p>"},{"location":"api/key/#modcskeyclearkeytrg","title":"ModCS.Key.ClearKeyTrg()","text":"<pre><code>ModCS.Key.ClearKeyTrg()\n</code></pre> <p>Clears the value of the games <code>gKeyTrg</code> value, setting it to 0.</p>"},{"location":"api/key/#modcskeygettrg","title":"ModCS.Key.GetTrg()","text":"<pre><code>ModCS.Key.GetTrg()\n</code></pre> <p>Run game input functions. Always gets run in the main gameplay loop, opening, and title loops, but should be run if you go out of that in your code.</p>"},{"location":"api/key/#modcskeykeydown","title":"ModCS.Key.KeyDown()","text":"<pre><code>ModCS.Key.KeyDown(kcode, kchar, krepeat)\n</code></pre> <p>Run code when the <code>kcode</code> (Win32 Keyboard Keycode) is pressed, with <code>kchar</code> being the character (if there is one). <code>krepeat</code> is true if its a repeated key press, holding down the key for a decent amount of time.</p>"},{"location":"api/key/#modcskeykeyup","title":"ModCS.Key.KeyUp()","text":"<pre><code>ModCS.Key.KeyUp(kcode, kchar)\n</code></pre> <p>Run code when the <code>kcode</code> (Win32 Keyboard Keycode) is released, with <code>kchar</code> being the character (if there is one).</p>"},{"location":"api/map/","title":"ModCS.Map","text":"<p>The ModCS.Map namespace contains functions related to Maps.</p> <p>Maps are a collection of files stored in the <code>/data/Stage/</code> folder. They are only usuable in-game via a Stage.</p> <p>Maps are composed of 3 types of files:</p> <ul> <li> <p>PXM (PixMap) files - For storing tile placement.</p> </li> <li> <p>PXE (PixEvent or PixEntity) - For storing NPC placement.</p> </li> <li> <p>TSC Files - For storing an individual map's TextScript.</p> </li> </ul>"},{"location":"api/map/#tile-unit","title":"Tile Unit","text":"<p>Map files (TSC included) use Tile Units for coordinates rather than Pixel Units. One Tile Unit is 16x16 Pixel Units.</p>"},{"location":"api/map/#modcsmapgetwidth","title":"ModCS.Map.GetWidth()","text":"<pre><code>ModCS.Map.GetWidth()\n</code></pre> <p>Returns the width in tile units of the current loaded map.</p>"},{"location":"api/map/#modcsmapgetheight","title":"ModCS.Map.GetHeight()","text":"<pre><code>ModCS.Map.GetHeight()\n</code></pre> <p>Returns the height in tile units of the current loaded map.</p>"},{"location":"api/map/#modcsmapgetattribute","title":"ModCS.Map.GetAttribute()","text":"<pre><code>ModCS.Map.GetAttribute(x, y)\n</code></pre> <p>Returns the attribute of the tile at tile unit coordinates <code>x</code> and <code>y</code>.</p>"},{"location":"api/map/#modcsmapchangetile","title":"ModCS.Map.ChangeTile()","text":"<pre><code>ModCS.Map.ChangeTile(no, x, y, smoke)\n</code></pre> <p>Changes the tile at tile unit coordinates <code>x</code> and <code>y</code> of the current map to tile <code>no</code>.</p> <p><code>smoke</code> is an optional parameter and a Boolean. If set to true, spawn smoke NPCs at the position of the changing tile.</p>"},{"location":"api/mod/","title":"ModCS.Mod","text":"<p>The ModCS.Mod namespace contains functions related to customizing releases of mods.</p>"},{"location":"api/mod/#modcsmodsetname","title":"ModCS.Mod.SetName()","text":"<pre><code>ModCS.Mod.SetName(name)\n</code></pre> <p>Sets the window title of the game to <code>name</code>. This function will only work at top-level.</p>"},{"location":"api/mod/#modcsmodsetauthor","title":"ModCS.Mod.SetAuthor()","text":"<pre><code>ModCS.Mod.SetAuthor(name)\n</code></pre> <p>Sets the author of game to <code>name</code>. The author will be displayed in the version window.</p>"},{"location":"api/mod/#modcsmodsetversion","title":"ModCS.Mod.SetVersion()","text":"<pre><code>ModCS.Mod.SetVersion(v1, v2, v3, v4)\n</code></pre> <p>Sets the version of the game to <code>v1</code>.<code>v2</code>.<code>v3</code>.<code>v4</code>. This version will be in the version window.</p>"},{"location":"api/mod/#modcsmodsetopening","title":"ModCS.Mod.SetOpening()","text":"<pre><code>ModCS.Mod.SetOpening(no, eve, wait)\n</code></pre> <p>Use Stage <code>no</code> for the opening sequence (Game Mode 1). <code>eve</code> and <code>wait</code> are optional parameters.</p> <p>If <code>eve</code> is specified Event <code>eve</code> will run once the opening sequence starts, otherwise Event 0 will run.</p> <p>If <code>wait</code> is specified, wait <code>wait</code> ticks during the opening before transferring to the title screen.</p>"},{"location":"api/mod/#modcsmodsetstart","title":"ModCS.Mod.SetStart()","text":"<pre><code>ModCS.Mod.SetStart(no, x, y, eve)\n</code></pre> <p>Sets the default New Game starting point. Parameters are the same as the ModCS.Stage.Transfer() function.</p>"},{"location":"api/mod/#modcsmodsetspikedamage","title":"ModCS.Mod.SetSpikeDamage()","text":"<pre><code>ModCS.Mod.SetSpikeDamage(damage)\n</code></pre> <p>Sets the damage of the Spike tile type (Attribute 0x42) to <code>damage</code>.</p>"},{"location":"api/mod/#modcsmodsetbosshp","title":"ModCS.Mod.SetBossHP()","text":"<pre><code>ModCS.Mod.SetBossHP(no, hp)\n</code></pre> <p>Sets the life of the map boss <code>no</code> to the <code>hp</code> value given. The table for map bosses in vanilla is as such:</p> <pre><code>1: Omega\n2: Balfrog\n3: Monster X\n4: Core\n5: Ironhead\n6: Dragon Sisters\n7: Undead Core\n8: Heavy Press\n9: Ballos Ball (Phase 2)\n10: Ballos Ball (Phase 4)\n</code></pre>"},{"location":"api/mod/#modcsmodsetstartmychar","title":"ModCS.Mod.SetStartMyChar()","text":"<pre><code>ModCS.Mod.SetStartMyChar(life, maxLife, direct)\n</code></pre> <p>Set the starting new-game state of the players current life to <code>life</code>, max life to <code>maxLife</code>, and direction to <code>direct</code>.</p>"},{"location":"api/modcs/","title":"ModCS Object - Basics","text":"<p>All of ModCS's API is contained in the ModCS global namespace.</p>"},{"location":"api/modcs/#modcswritelog","title":"ModCS.WriteLog()","text":"<pre><code>ModCS.WriteLog(text, number1, number2, number3)\n</code></pre> <p>Write given data to a <code>error.log</code> file located in the same directory as the executable.</p> <p>All number parameters are optional, and will be casted to integers.</p>"},{"location":"api/modcs/#modcsputtext","title":"ModCS.PutText()","text":"<pre><code>ModCS.PutText(text, x, y, color, surface)\n</code></pre> <p>Draw given text to screen at coordinates <code>x</code> and <code>y</code>.  <code>color</code> and <code>surface</code> parameters are optional. </p> <p>If a color is not specified the text will have the color <code>255, 255, 254</code> (<code>#FFFFFE</code>).</p> <p>When a surface is specified, ModCS.PutText will draw to given surface instead.</p>"},{"location":"api/modcs/#modcsputnumber","title":"ModCS.PutNumber()","text":"<pre><code>ModCS.PutNumber(number, x, y, zero, surface)\n</code></pre> <p>Draw given number to screen at coordinates <code>x</code> and <code>y</code>.  <code>zero</code> and <code>surface</code> parameters are optional. </p> <p>Number parameters over 9999 will display capped.</p> <p><code>zero</code> is a Boolean. If set to true a zero will be shown to the left of the number. This only applies to one-digit numbers.</p> <p>When a surface is specified, ModCS.PutNumber will draw to given surface instead.</p>"},{"location":"api/modcs/#modcsgetfullrect","title":"ModCS.GetFullRect()","text":"<p>Returns a full ModCS.Rect. This rect will usually equal to this: <pre><code>{\n    left = 0,\n    top = 0,\n    right = 320,\n    bottom = 240\n}\n</code></pre></p>"},{"location":"api/modcs/#modcsgetgamerect","title":"ModCS.GetGameRect()","text":"<p>Returns the canvas ModCS.Rect of the game. This rect will usually equal to this: <pre><code>{\n    left = 0,\n    top = 0,\n    right = 320,\n    bottom = 240\n}\n</code></pre> During the credits sequence the rect's <code>left</code> value will equal to 160.</p> <p>Note</p> <p>The main difference between ModCS.GetGameRect() and ModCS.GetFullRect() is how both values are used in the original game itself. The full Rect is often the default view limiting value for drawing a bitmap, while the game Rect is the view limiting value for game related objects (NPCs, player, map tiles, etc.). You can use these Rects with ModCS.Rect.PutEx()</p>"},{"location":"api/modcs/#modcsgetdatapath","title":"ModCS.GetDataPath()","text":"<p>Returns the path of the data folder the game is using.</p>"},{"location":"api/modcs/#modcsgetmodulepath","title":"ModCS.GetModulePath()","text":"<p>Returns the path of the folder the games executable is located in.</p>"},{"location":"api/modcs/#modcssetdatapath","title":"ModCS.SetDataPath()","text":"<pre><code>ModCS.SetDataPath(\"NewPathHere\")\n</code></pre> <p>Set the data path of the game to the argument you give it. It is advised to use lua string functions with the Module Path to change the data path.</p>"},{"location":"api/modcs/#modcssetmodulepath","title":"ModCS.SetModulePath()","text":"<pre><code>ModCS.SetModulePath(\"NewPathHere\")\n</code></pre> <p>Set the module path of the game to the argument you give it. It is ill-advised to do this, unless you know what you're doing.</p>"},{"location":"api/modcs/#modcsaddcaret","title":"ModCS.AddCaret()","text":"<pre><code>ModCS.AddCaret(\"MyCaretName\")\n</code></pre> <p>For AutPI compatibility, if you add new carets you should add them using this command first, so other dll mods or scripts dont interfere with what you're doing. This simply adds a blank slot letting the game know its already being used.</p>"},{"location":"api/modcs/#modcsaddentity","title":"ModCS.AddEntity()","text":"<pre><code>ModCS.AddEntity(\"MyEntityName\")\n</code></pre> <p>For AutPI compatibility, if you add new entities you should add them using this command first, so other dll mods or scripts dont interfere with what you're doing. This simply adds a blank slot letting the game know its already being used.</p>"},{"location":"api/modcs/#modcssystemtask","title":"ModCS.SystemTask()","text":"<p>Returns <code>true</code> if the game is currently running tasks, and runs its code.</p> <p>This is for advanced users!</p>"},{"location":"api/modcs/#modcsshutdown","title":"ModCS.ShutDown()","text":"<p>Immediately shutdown the game.</p>"},{"location":"api/modcs/#modcscallescape","title":"ModCS.CallEscape()","text":"<p>Brings up the Escape Menu.</p>"},{"location":"api/modcs/#modcssetmag","title":"ModCS.SetMag()","text":"<pre><code>ModCS.SetMag(number)\n</code></pre> <p>Set the games \"magnification\" factor to a different value. This is how the game decides to resize sprites in different window resolutions and scales them up properly.</p> <pre><code>Magnification 1 = 320x240\nMagnification 2 = 640x480\n</code></pre> <p>This could be useful to advanced users who want to load a larger surface while the game size is higher than magnification 1.</p>"},{"location":"api/modcs/#modcsgetmag","title":"ModCS.GetMag()","text":"<p>Returns the current <code>mag</code> value the game is using.</p>"},{"location":"api/modloader/","title":"ModCS.ModLoader","text":"<p>The ModCS.ModLoader namespace contains functions related to the Cave Story Mod Loader, developed by Clownacy.</p>"},{"location":"api/modloader/#modcsmodloaderwritebyte","title":"ModCS.ModLoader.WriteByte()","text":"<pre><code>ModCS.ModLoader.WriteByte(address, number)\n</code></pre> <p>Replace the byte at <code>address</code> with the <code>number</code> given.</p>"},{"location":"api/modloader/#modcsmodloaderwriteword","title":"ModCS.ModLoader.WriteWord()","text":"<pre><code>ModCS.ModLoader.WriteWord(address, number)\n</code></pre> <p>Replace the word (2 bytes) at <code>address</code> with the <code>number</code> given.</p>"},{"location":"api/modloader/#modcsmodloaderwritelong","title":"ModCS.ModLoader.WriteLong()","text":"<pre><code>ModCS.ModLoader.WriteLong(address, number)\n</code></pre> <p>Replace the long (4 bytes) at <code>address</code> with the <code>number</code> given.</p>"},{"location":"api/modloader/#modcsmodloaderwritewordbe","title":"ModCS.ModLoader.WriteWordBE()","text":"<pre><code>ModCS.ModLoader.WriteWordBE(address, number)\n</code></pre> <p>Replace the word (2 bytes) at <code>address</code> with the <code>number</code> given, in Big Endian format (reversed byte order).</p>"},{"location":"api/modloader/#modcsmodloaderwritelongbe","title":"ModCS.ModLoader.WriteLongBE()","text":"<pre><code>ModCS.ModLoader.WriteLongBE(address, number)\n</code></pre> <p>Replace the long (4 bytes) at <code>address</code> with the <code>number</code> given, in Big Endian format (reversed byte order).</p>"},{"location":"api/modloader/#modcsmodloadergetbyte","title":"ModCS.ModLoader.GetByte()","text":"<pre><code>ModCS.ModLoader.GetByte(address)\n</code></pre> <p>Returns the byte found at <code>address</code>.</p>"},{"location":"api/modloader/#modcsmodloadergetword","title":"ModCS.ModLoader.GetWord()","text":"<pre><code>ModCS.ModLoader.GetWord(address)\n</code></pre> <p>Returns the word found at <code>address</code>.</p>"},{"location":"api/modloader/#modcsmodloadergetlong","title":"ModCS.ModLoader.GetLong()","text":"<pre><code>ModCS.ModLoader.GetLong(address)\n</code></pre> <p>Returns the long found at <code>address</code>.</p>"},{"location":"api/profile/","title":"ModCS.Profile","text":"<p>The ModCS.Mod namespace contains functions related to the save files of mods.</p>"},{"location":"api/profile/#modcsprofilesave","title":"ModCS.Profile.Save()","text":"<pre><code>ModCS.Profile.Save(\"ProfileName.dat\")\n</code></pre> <p>Saves the game when the function is called. The argument is optional, and will save as the standard Profile.dat if there is no string attached.</p>"},{"location":"api/profile/#modcsprofileload","title":"ModCS.Profile.Load()","text":"<pre><code>ModCS.Profile.Load(\"ProfileName.dat\")\n</code></pre> <p>Loads the game when the function is called. The argument is optional, and will load the standard Profile.dat if there is no string attached.</p>"},{"location":"api/profile/#modcsprofileduringsave","title":"ModCS.Profile.DuringSave()","text":"<p>This function is called whenever the game is saved.</p> Example <p>This example will print \"Saving!\" on every save. <pre><code>function ModCS.Profile.DuringSave()\n    print(\"Saving!\")\nend\n</code></pre></p>"},{"location":"api/profile/#modcsprofileduringload","title":"ModCS.Profile.DuringLoad()","text":"<p>This function is called whenever the game is loaded.</p> Example <p>This example will print \"Loading!\" on every load. <pre><code>function ModCS.Profile.DuringLoad()\n    print(\"Loading!\")\nend\n</code></pre></p>"},{"location":"api/stage/","title":"ModCS.Stage","text":"<p>The ModCS.Stage namespace contains functions related to Stages.</p>"},{"location":"api/stage/#stage-table","title":"Stage Table","text":"<p>The stage table is where all of the game's stages are defined. A stage table entry has the following values:</p> Value Usage Map Filename The filename used for loading map and TSC files. Stage Name The name of the stage that will be shown in the minimap and in <code>&lt;MNA</code>. Tileset The filename used for loading the tileset bitmap and PXA file. NPC Sheet 1 Filename The filename used for loading a bitmap to the NPC Spritesheet 1 surface. NPC Sheet 2 Filename The filename used for loading a bitmap to the NPC Spritesheet 2 surface. Background Filename The filename used for loading a bitmap to the Background surface. Background Scroll Type A number which represents how the background will act. Boss Number i am being forced to write these docs please send help <p>The Stage Table is stored in a <code>stage.tbl</code> file that can be found in the <code>data</code> folder. Usually Cave Story map editors heavily depend on the Stage Table to load the correct tilesets, backgrounds and NPC Sheets when the user wants to edit a map. Most editors also do not allow you to edit maps which do not have a defined stage.</p> <p>Note</p> <p>In the original game the Stage Table is not stored in a seperate file but hardcoded into the game executable instead.</p>"},{"location":"api/stage/#modcsstagetransfer","title":"ModCS.Stage.Transfer()","text":"<pre><code>ModCS.Stage.Transfer(no, x, y, eve)\n</code></pre> <p>Transfer to stage <code>no</code>.</p> <p>If <code>x</code> and <code>y</code> are specified, change the player's tile coordinates to <code>x</code> and <code>y</code>.</p> <p>If <code>eve</code> is specified, run TSC Event <code>eve</code> after transferring to the stage. Run Event 0 otherwise.</p>"},{"location":"api/stage/#modcsstagegetcurrentno","title":"ModCS.Stage.GetCurrentNo()","text":"<pre><code>ModCS.Stage.GetCurrentNo()\n</code></pre> <p>Returns the current stage's number.</p>"},{"location":"api/stage/#modcsstagegetfilename","title":"ModCS.Stage.GetFilename()","text":"<pre><code>ModCS.Stage.GetFilename(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetname","title":"ModCS.Stage.GetName()","text":"<pre><code>ModCS.Stage.GetName(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the stage name value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the stage name value of the current stage.</p>"},{"location":"api/stage/#modcsstagegettileset","title":"ModCS.Stage.GetTileset()","text":"<pre><code>ModCS.Stage.GetTileset(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the tileset filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the tileset filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetnpcsheet1","title":"ModCS.Stage.GetNpcSheet1()","text":"<pre><code>ModCS.Stage.GetNpcSheet1(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the NPC Sheet 1 filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the NPC Sheet 1 filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetnpcsheet2","title":"ModCS.Stage.GetNpcSheet2()","text":"<pre><code>ModCS.Stage.GetNpcSheet1(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the NPC Sheet 2 filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the NPC Sheet 2 filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetbackground","title":"ModCS.Stage.GetBackground()","text":"<pre><code>ModCS.Stage.GetBackground(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the Background filename value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the Background filename value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetbackgroundmode","title":"ModCS.Stage.GetBackgroundMode()","text":"<pre><code>ModCS.Stage.GetBackgroundMode(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the Background mode value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the Background mode value of the current stage.</p>"},{"location":"api/stage/#modcsstagegetbossno","title":"ModCS.Stage.GetBossNo()","text":"<pre><code>ModCS.Stage.GetBossNo(no)\n</code></pre> <p><code>no</code> is an optional parameter. Returns the Boss value of stage table entry <code>no</code>. If <code>no</code> is not specified, return the Boss value of the current stage.</p>"},{"location":"api/stage/#modcsstageloadtable","title":"ModCS.Stage.LoadTable()","text":"<pre><code>ModCS.Stage.LoadTable(\"stage.tbl\")\n</code></pre> <p>Loads a <code>stage.tbl</code> file from the argument given, using that instead of the internal exe table.</p>"},{"location":"api/stage/#modcsstageontransfer","title":"ModCS.Stage.OnTransfer()","text":"<p>This function is called whenever a map is changed, via <code>&lt;TRA</code> or <code>ModCS.Stage.Transfer()</code>.</p> Example <p>This example will print \"Transferring Stage!\" on every map change. <pre><code>function ModCS.Stage.OnTransfer()\n    print(\"Transferring Stage!\")\nend\n</code></pre></p>"},{"location":"api/tsc/","title":"ModCS.Tsc","text":"<p>The ModCS.Tsc namespace contains functions related to TextScript (Also known as T-Script).</p> <p>TextScript is vanilla Cave Story's scripting language. Combined with Flags it's used for textboxes, animations, cutscenes, etc.</p>"},{"location":"api/tsc/#commands","title":"Commands","text":"<p>TextScript's syntax is composed of commands (or \"codes\") that do certain actions. When the TSC parser reaches a <code>&lt;</code> symbol it checks the next 3 symbols and compares them to its list of commands. If no command is found an error will occur.</p> <p>... Here I would put my own TSC command list but I'm currently too lazy. Please refer to your map editor's TSC list or this TXT list instead.</p>"},{"location":"api/tsc/#events","title":"Events","text":"<p>TextScript scripts are seperated into Events, which are runnable sets of actions and text.</p> <p>Events are a defined with a <code>#</code> and 4 following digits, which together represent the Event number. Events are usually ended with <code>&lt;END</code>.</p> Example <p>This is a basic TSC example event which opens a textbox. <pre><code>#0100\n&lt;KEY&lt;MSGHello World&lt;NOD&lt;CLO&lt;END\n</code></pre></p>"},{"location":"api/tsc/#modcstscisrunning","title":"ModCS.Tsc.IsRunning()","text":"<p>Returns true if a TextScript event is running. Returns false otherwise.</p>"},{"location":"api/tsc/#modcstscrun","title":"ModCS.Tsc.Run()","text":"<pre><code>ModCS.Tsc.Run(event)\n</code></pre> <p>Run TextScript Event <code>event</code>.</p> <p>Warning</p> <p>It's recommended to only use <code>ModCS.Tsc.Run()</code> when a TextScript event isn't running.</p> <p>If you want to run a different Event during another Event please use ModCS.Tsc.Jump() instead.</p>"},{"location":"api/tsc/#modcstscjump","title":"ModCS.Tsc.Jump()","text":"<pre><code>ModCS.Tsc.Jump(event)\n</code></pre> <p>Jump to TextScript Event <code>event</code> while another Event is running.</p>"},{"location":"api/tsc/#modcstscwait","title":"ModCS.Tsc.Wait()","text":"<pre><code>ModCS.Tsc.Wait(ticks)\n</code></pre> <p>During a TextScript event, wait <code>ticks</code> ticks before running the next command.</p>"},{"location":"api/tsc/#modcstscgetargument","title":"ModCS.Tsc.GetArgument()","text":"<pre><code>ModCS.Tsc.GetArgument(no)\n</code></pre> <p>During a custom TextScript command, get the <code>no</code> argument of the running command. Calling this function will also 'skip' the argument from the TSC parser.</p>"},{"location":"api/tsc/#modcstscgetstring","title":"ModCS.Tsc.GetString()","text":"<pre><code>ModCS.Tsc.GetString(\"String\")\n</code></pre> <p>During a custom TextScript command, get the <code>string</code> argument of the running command. Calling this function will also 'skip' the argument from the TSC parser.</p> Example <p>This is an example of a string used in tsc, if we had 1 string argument and wanted to use \"Test\" as our string in the TSC: <pre><code>&lt;STRTest$\n</code></pre></p>"},{"location":"api/tsc/#custom-commands","title":"Custom Commands","text":"<p>ModCS allows you to overwrite TextScript commands and to have custom ones as well. If a function <code>ModCS.Tsc.Command.XXX</code> is defined (where XXX is the custom command) the function will run when the TextScript parser reaches command <code>&lt;XXX</code>.</p> Example <p>This is an example function for a TextScript command that will print its first argument to the debug console. <pre><code>function ModCS.Tsc.Command.FOO()\n    local no = ModCS.Tsc.GetArgument(1) -- Get the first argument of the running command\n    print(no)\nend\n</code></pre></p> <pre><code>#0100\n&lt;FOO0002&lt;END\n</code></pre> <p>Console output: <pre><code>2\n</code></pre></p>"},{"location":"api/drawing/color/","title":"ModCS.Color","text":"<p>The ModCS.Color class represents colors. They are stored in a RGB format.</p> <p>A ModCS.Color is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>red</code> Number (Casted to integer) Red value of an RGB color (0-255). <code>green</code> Number (Casted to integer) Green value of an RGB color (0-255). <code>blue</code> Number (Casted to integer) Blue value of an RGB color (0-255)."},{"location":"api/drawing/color/#modcscolorcreate","title":"ModCS.Color.Create()","text":"<pre><code>ModCS.Color.Create(red, green, blue)\n</code></pre> <p>Returns a ModCS.Color.</p> <p>All parameters are optional. If any parameters are given, the returned ModCS.Color will use those parameters as RGB values.</p>"},{"location":"api/drawing/color/#modcscolorset","title":"ModCS.Color.Set()","text":"<pre><code>ModCS.Color.Set(color, red, green, blue)\n</code></pre> <p>Sets the ModCS.Color given in the <code>color</code> parameter to a ModCS.Color with the following parameters.</p>"},{"location":"api/drawing/color/#modcscolorbox","title":"ModCS.Color.Box()","text":"<pre><code>ModCS.Color.Box(color, x, y, width, height, surface)\nModCS.Color.Box(color, rect, surface)\n</code></pre> <p>Draw a colored box to the screen at coordinates <code>x</code> and <code>y</code> with width <code>width</code> and height <code>height</code>.</p> <p>The <code>surface</code> parameter is optional. If it's specified, draw a colored box to surface with ID <code>surface</code> instead.</p> <p>Note</p> <p>For a more traditional CortBox usage you may specify a <code>rect</code> instead of coordinates and size.</p>"},{"location":"api/drawing/rect/","title":"ModCS.Rect","text":"<p>The ModCS.Rect class represents Rects. They are a collection of pixel coordinates on a Surface which represent a part of the surface. They are mostly used for displaying different sprites from a spritesheet.</p> <p>A ModCS.Rect is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>left</code> Number (Casted to integer) X coordinate of the upper-left corner of the Rect. <code>top</code> Number (Casted to integer) Y coordinate of the upper-left corner of the Rect. <code>right</code> Number (Casted to integer) X coordinate of the down-right corner of the Rect. <code>bottom</code> Number (Casted to integer) Y coordinate of the down-right corner of the Rect. Rect Example <p>This example shows you how to get the Rect of the number 4 sprite from TextBox.bmp</p> <p></p> <p>The coordinates of the upper-left corner are 32, 56. The coordinates of the down-right corner are 40, 64. Therefore, the Rect of the number 4 sprite is:</p> <pre><code>{\n    left = 32,\n    top = 56,\n    right = 40,\n    bottom = 64\n}\n</code></pre>"},{"location":"api/drawing/rect/#modcsrectcreate","title":"ModCS.Rect.Create()","text":"<pre><code>ModCS.Rect.Create(left, top, right, bottom)\n</code></pre> <p>Returns a ModCS.Rect.</p> <p>All parameters are optional. If any parameters are given, the returned ModCS.Rect will use those parameters as Rect values.</p>"},{"location":"api/drawing/rect/#modcsrectset","title":"ModCS.Rect.Set()","text":"<pre><code>ModCS.Rect.Set(rect, left, top, right, bottom)\n</code></pre> <p>Sets the ModCS.Rect given in the <code>rect</code> parameter to a ModCS.Rect with the following parameters.</p>"},{"location":"api/drawing/rect/#modcsrectput","title":"ModCS.Rect.Put()","text":"<pre><code>ModCS.Rect.Put(rect, x, y, surface, alpha)\nModCS.Rect.Put(rect, x, y, surface, surfaceto)\n</code></pre> <p>Draw the given Rect from the surface with ID <code>surface</code> to the screen with coordinates <code>x</code> and <code>y</code>.</p> <p>The <code>alpha</code> parameter is optional and is a Boolean. If set to false the game will draw the rect without removing any fully black pixels. The default value is true.</p> <p>The <code>surfaceto</code> parameter is optional and is a number. If set the game will draw the rect to the surface with ID <code>surfaceto</code>.</p> <p>Note</p> <p>For a more traditional PutBitmap usage you may use ModCS.Rect.PutEx().</p>"},{"location":"api/drawing/rect/#modcsrectputex","title":"ModCS.Rect.PutEx()","text":"<pre><code>ModCS.Rect.PutEx(rect, viewrect, x, y, surface, alpha)\n</code></pre> <p>The same as ModCS.Rect.Put() but with a <code>viewrect</code> which limits the view.</p>"},{"location":"api/drawing/surface/","title":"ModCS.Surface","text":"<p>The ModCS.Surface class represents drawing surfaces. Surfaces are image data types which contain pixels of an image.</p>"},{"location":"api/drawing/surface/#surface-id-table","title":"Surface ID Table","text":"<p>Surfaces are represented by an ID. This table contains all vanilla game surfaces.</p> Value Description Additional Info 0 Title screen This surface is created from the bitmap file <code>/data/Title.bmp</code>. 1 Studio Pixel logo This surface is created from the bitmap file <code>/data/pixel.bmp</code>. 2 Level tileset This surface is used by the game to draw tiles. The game loads the tileset bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 256x256. 6 Fade effect This surface is created from the bitmap file <code>/data/Fade.bmp</code>. 7 HUD This surface is exclusive to ModCS. The game draws all HUD elements to this surface. 8 Items This surface is created from the bitmap file <code>/data/ItemImage.bmp</code>. 9 Minimap This surface is used by the game to draw the Minimap. Its size is 320x240. 10 Screenshot This surface is used by the game to display game loops in other game loops. For example, when the player enters the inventory screen, the game screenshots itself and draws this screenshot to this surface. When the inventory screen is drawn the game first draws the screenshot surface as a background and then draws the inventory screen itself. This surface's size is 320x240. 11 Arms This surface is created from the bitmap file <code>/data/Arms.bmp</code>. 12 Arms Image This surface is created from the bitmap file <code>/data/ArmsImage.bmp</code>. 13 Room name This surface is used by the game for drawing the room name to. This surface's size is 160x16. 14 Stage item This surface is created from the bitmap file <code>/data/StageImage.bmp</code>. 15 Loading This surface is created from the bitmap file <code>/data/Loading.bmp</code>. 16 Player This surface is created from the bitmap file <code>/data/MyChar.bmp</code>. 17 Bullet This surface is created from the bitmap file <code>/data/Bullet.bmp</code>. 19 Caret This surface is created from the bitmap file <code>/data/Caret.bmp</code>. 20 NPC System This surface is created from the bitmap file <code>/data/Npc/NpcSym.bmp</code>. 21 NPC Spritesheet 1 The game loads the NPC Spritesheet 1 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 22 NPC Spritesheet 2 The game loads the NPC Spritesheet 2 bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 23 NPC Regular This surface is created from the bitmap file <code>/data/Npc/NpcRegu.bmp</code>. 26 Textbox This surface is created from the bitmap file <code>/data/TextBox.bmp</code>. 27 Face This surface is created from the bitmap file <code>/data/Face.bmp</code>. 28 Level background The game loads the Background bitmap file specified in the Stage Table entry for each map to this surface when the player transfers to that map. This surface's size is 320x240. 29 Value view The game draws damage and XP indicators to this surface. This surface's size is 40x240. 30-34 Text line surfaces from 1 to 5 These surfaces are used by the game for drawing TSC text to. These surfaces are only initialized when TSC starts. Their size is 216x16. The game needs 5 of these for the text scrolling effect. 35 Credits text This surface is used by the game for drawing the credits text to. Its height varies on the credits TSC, but its width is 320. 36 Credits image This surface is created from the bitmap file <code>/data/Credits/Credit01.bmp</code>. It can be swapped with other <code>Credit</code> bitmaps during the credits TSC. 37 Casts This surface is created from the bitmap file <code>/data/Npc/casts.bmp</code> when the credits start. <p>Note</p> <p>In the original game, more than 40 surfaces could not be created. In ModCS this number has been increased to 50 to allow for more custom surfaces.</p>"},{"location":"api/drawing/surface/#modcssurfacecreate","title":"ModCS.Surface.Create()","text":"<pre><code>ModCS.Surface.Create(id, width, height)\nModCS.Surface.Create(id, path)\n</code></pre> <p>Create a surface. Returns a ModCS.Surface which contains the ID of the surface.</p> <p>If <code>width</code> and <code>height</code> are specified, create a generic surface with those sizes.</p> <p>If a <code>path</code> is specified, create a surface with the bitmap given in that path. The path's root is always the game's data folder. Do not add a <code>.bmp</code> file extension to the path. Surfaces created from bitmap files use the specified bitmap file's size.</p> Example <p>This example will create two surfaces, one basic and one from a file. <pre><code>BarSurface = ModCS.Surface.Create(41, 320, 240) -- Create a surface with ID 41 with size 320x240\nFooSurface = ModCS.Surface.Create(42, \"Foo\") -- Create a surface with ID 42 using /data/Foo.bmp\n</code></pre></p> <p>Note</p> <p>When creating custom surfaces, it's reccomended to use surface IDs over 40, as it's possible in the future for ModCS to add new custom surfaces below this number.</p>"},{"location":"api/drawing/surface/#modcssurfaceloadbitmap","title":"ModCS.Surface.LoadBitmap()","text":"<pre><code>ModCS.Surface.LoadBitmap(id, path)\n</code></pre> <p>Draw the bitmap file specified in <code>path</code> to a surface with ID <code>id</code>. The path's root is always the game's data folder. Do not add a <code>.bmp</code> file extension to the path.</p>"},{"location":"api/drawing/surface/#modcssurfacescreenshot","title":"ModCS.Surface.Screenshot()","text":"<pre><code>ModCS.Surface.Screenshot(id, rect)\n</code></pre> <p>Draw a screenshot of the current state of the game to Surface with ID <code>id</code>.</p> <p><code>rect</code> is an optional parameter. If specified only <code>rect</code> of the screen will be drawn to the Surface. </p>"},{"location":"api/flags/flag/","title":"ModCS.Flag","text":"<p>The ModCS.Flag namespace contains functions related to Flags.</p> <p>Flags are in-game \"switches\" that are used to record the player's progress, and are saved to the save file when the player saves the game. The maximum flag is 8000.</p>"},{"location":"api/flags/flag/#hardcoded-flags","title":"Hardcoded flags","text":"<p>There are two flags that change game properties outside of TSC:</p> <ul> <li> <p>If flag <code>4000</code> is set, when the player drowns, instead of the normal drown event, event 1100 will start. This is used in the vanilla game for the after Core boss cutscene.</p> </li> <li> <p>If flag <code>563</code> is not set, the Curly AI NPC will not shoot bullets. (Citation needed)</p> </li> </ul>"},{"location":"api/flags/flag/#modcsflagset","title":"ModCS.Flag.Set()","text":"<pre><code>ModCS.Flag.Set(no)\n</code></pre> <p>Sets (Or \"Switches on\") the flag <code>no</code>.</p>"},{"location":"api/flags/flag/#modcsflagunset","title":"ModCS.Flag.Unset()","text":"<pre><code>ModCS.Flag.UnSet(no)\n</code></pre> <p>Unsets (Or \"Switches off\") the flag <code>no</code>.</p>"},{"location":"api/flags/flag/#modcsflagget","title":"ModCS.Flag.Get()","text":"<pre><code>ModCS.Flag.Get(no)\n</code></pre> <p>Returns true if the flag <code>no</code> is set. Returns false otherwise.</p>"},{"location":"api/flags/skipflag/","title":"ModCS.SkipFlag","text":"<p>The ModCS.SkipFlag namespace contains functions related to Skipflags.</p> <p>Unlike Flags Skipflags do not save to the save file and will reset if the player closes the game. They are used if the player dies after viewing a long cutscene and would have to rewatch a cutscene if a skipflag was not used for it. The maximum skipflag is 64.</p>"},{"location":"api/flags/skipflag/#modcsskipflagset","title":"ModCS.SkipFlag.Set()","text":"<pre><code>ModCS.SkipFlag.Set(no)\n</code></pre> <p>Sets (Or \"Switches on\") the skipflag <code>no</code>.</p>"},{"location":"api/flags/skipflag/#modcsskipflagunset","title":"ModCS.SkipFlag.Unset()","text":"<pre><code>ModCS.SkipFlag.UnSet(no)\n</code></pre> <p>Unsets (Or \"Switches off\") the skipflag <code>no</code>.</p>"},{"location":"api/flags/skipflag/#modcsskipflagget","title":"ModCS.SkipFlag.Get()","text":"<pre><code>ModCS.SkipFlag.Get(no)\n</code></pre> <p>Returns true if the skipflag <code>no</code> is set. Returns false otherwise.</p>"},{"location":"api/inventory/arms/","title":"ModCS.Arms","text":"<p>The ModCS.Arms class represents weapons that can be accessed from the inventory. The game has enough memory for 8 different weapons to be stored in the inventory.</p> <p>A ModCS.Arms is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>id</code> Number (Casted to integer) Type ID of the weapon. <code>level</code> Number (Casted to integer) The weapon's level. <code>exp</code> Number (Casted to integer) The weapon's exp. Resets to 0 after every level up. <code>ammo</code> Number (Casted to integer) The weapon's current ammo count. <code>max_ammo</code> Number (Casted to integer) The maximum ammo of the weapon. If this is set to 0 the weapon will not have an ammo requirement."},{"location":"api/inventory/arms/#modcsarmsadd","title":"ModCS.Arms.Add()","text":"<pre><code>ModCS.Arms.Add(id, ammo)\n</code></pre> <p>Adds weapon of type <code>id</code> to the inventory. If a weapon of type <code>id</code> exists, update it.</p> <p><code>ammo</code> is an optional parameter. If specified, the added weapon will have maximum <code>ammo</code> ammo count.</p>"},{"location":"api/inventory/arms/#modcsarmsremove","title":"ModCS.Arms.Remove()","text":"<pre><code>ModCS.Arms.Remove(id)\n</code></pre> <p>Removes weapon of type <code>id</code> from the inventory.</p>"},{"location":"api/inventory/arms/#modcsarmsuseammo","title":"ModCS.Arms.UseAmmo()","text":"<pre><code>ModCS.Arms.UseAmmo(no)\n</code></pre> <p><code>no</code> is an optional parameter, if not specified <code>no</code> will be set to 1.</p> <p>Use <code>no</code> amount of ammo from the currently selected weapon. Returns false if the amount of ammo can't be used. Returns true otherwise.</p>"},{"location":"api/inventory/arms/#modcsarmsaddammo","title":"ModCS.Arms.AddAmmo()","text":"<pre><code>ModCS.Arms.AddAmmo(no)\n</code></pre> <p>Adds <code>no</code> amount of ammo to the currently selected weapon.</p>"},{"location":"api/inventory/arms/#modcsarmsswitchnext","title":"ModCS.Arms.SwitchNext()","text":"<pre><code>ModCS.Arms.SwitchNext()\n</code></pre> <p>Switches the currently selected weapon to the next one.</p>"},{"location":"api/inventory/arms/#modcsarmsswitchprev","title":"ModCS.Arms.SwitchPrev()","text":"<pre><code>ModCS.Arms.SwitchPrev()\n</code></pre> <p>Switches the currently selected weapon to the previous one.</p>"},{"location":"api/inventory/arms/#modcsarmsswitchfirst","title":"ModCS.Arms.SwitchFirst()","text":"<pre><code>ModCS.Arms.SwitchFirst()\n</code></pre> <p>Switches the currently selected weapon to the first weapon in the inventory.</p>"},{"location":"api/inventory/arms/#modcsarmsaddexp","title":"ModCS.Arms.AddExp()","text":"<pre><code>ModCS.Arms.AddExp(exp)\n</code></pre> <p>Adds <code>exp</code> amount of XP to the player.</p>"},{"location":"api/inventory/arms/#modcsarmsremoveexp","title":"ModCS.Arms.RemoveExp()","text":"<pre><code>ModCS.Arms.RemoveExp(exp)\n</code></pre> <p>Removes <code>exp</code> amount of XP from the player.</p>"},{"location":"api/inventory/arms/#modcsarmsgetlevels","title":"ModCS.Arms.GetLevels()","text":"<pre><code>ModCS.Arms.GetLevels(id)\n</code></pre> <p>Returns an array of the XP requirements for each level of weapon of type <code>id</code>. These values are read from the <code>data/arms_level.tbl</code> file.</p>"},{"location":"api/inventory/arms/#modcsarmsgetcurrent","title":"ModCS.Arms.GetCurrent()","text":"<pre><code>ModCS.Arms.GetCurrent()\n</code></pre> <p>Returns a ModCS.Arms of the currently selected weapon.</p>"},{"location":"api/inventory/arms/#modcsarmsgetcurrentinvpos","title":"ModCS.Arms.GetCurrentInvPos()","text":"<pre><code>ModCS.Arms.GetCurrentInvPos()\n</code></pre> <p>Returns the inventory position of the currently selected weapon.</p>"},{"location":"api/inventory/arms/#modcsarmsgetbyid","title":"ModCS.Arms.GetByID()","text":"<pre><code>ModCS.Arms.GetByID(id)\n</code></pre> <p>Searched the inventory for a weapon with type ID <code>id</code>. If found, return a ModCS.Arms of that weapon. Otherwise return a nil value.</p>"},{"location":"api/inventory/arms/#modcsarmsgetbyinvpos","title":"ModCS.Arms.GetByInvPos()","text":"<pre><code>ModCS.Arms.GetByInvPos(pos)\n</code></pre> <p>Return a ModCS.Arms of the weapon at inventory position <code>pos</code>.</p>"},{"location":"api/inventory/arms/#weapon-shoot-code","title":"Weapon Shoot Code","text":"<p>The way Cave Story weapons work internally is a certain function runs on loop if the player is currently holding a certain type of weapon. ModCS allows you to override a weapon's shoot code. If a function in the <code>ModCS.Arms.Shoot</code> array is defined with the index <code>X</code> (where <code>X</code> is the Weapon Type ID you want to override) in your Lua script the game will run that function instead of the built-in shoot function.</p> Example <pre><code>ModCS.Arms.Shoot[1] = function()\n    -- ...\nend\n</code></pre>"},{"location":"api/inventory/item/","title":"ModCS.Item","text":"<p>The ModCS.Item class represents non-weapon items that can be accessed from the inventory. The game has enough memory for 32 different items to be stored in the inventory.</p> <p>A ModCS.Item is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>id</code> Number (Casted to integer) Type ID of the item."},{"location":"api/inventory/item/#modcsitemadd","title":"ModCS.Item.Add()","text":"<pre><code>ModCS.Item.Add(id)\n</code></pre> <p>Adds item of type <code>id</code> to the inventory.</p>"},{"location":"api/inventory/item/#modcsitemremove","title":"ModCS.Item.Remove()","text":"<pre><code>ModCS.Item.Remove(id)\n</code></pre> <p>Removes item of type <code>id</code> from the inventory.</p>"},{"location":"api/inventory/item/#modcsitemgetbyid","title":"ModCS.Item.GetByID()","text":"<pre><code>ModCS.Item.GetByID(id)\n</code></pre> <p>Searched the inventory for an item with type ID <code>id</code>. If found, return a ModCS.Item of that item. Otherwise return a nil value.</p>"},{"location":"api/inventory/item/#modcsitemgetbyinvpos","title":"ModCS.Item.GetByInvPos()","text":"<pre><code>ModCS.Item.GetByInvPos(pos)\n</code></pre> <p>Return a ModCS.Item of the item at inventory position <code>pos</code>.</p>"},{"location":"api/objects/bullet/","title":"ModCS.Bullet","text":"<p>The ModCS.Bullet class represents Bullets. Bullets are game objects usually shot by the player to damage Ememy NPCs. Bullets will always damage vulnerable NPCs after being shot. Unlike NPCs Bullets only draw from the Bullet Surface.</p> <p>A ModCS.Bullet is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit X position of the Bullet. <code>y</code> Pixel Unit Y position of the Bullet. <code>xm</code> Pixel Unit X velocity of the Bullet. This value does nothing by itself, but can be used with ModCS.Bullet.Move(). <code>ym</code> Pixel Unit Y velocity of the Bullet. This value does nothing by itself, but can be used with ModCS.Bullet.Move(). <code>tgt_x</code> Pixel Unit Target X value. This variable does nothing by itself. <code>tgt_y</code> Pixel Unit Target Y value. This variable does nothing by itself. <code>id</code> Bullet Type ID ID of the Bullet. <code>life</code> Number (Casted to integer) How many frames the Bullet will stay on screen after hitting an Enemy. <code>life_count</code> Number (Casted to integer) Range of the Bullet. This value does nothing by itself but can be used to determine how long the Bullet will last on screen after being spawned. <code>damage</code> Number (Casted to integer) How much damage the bullet will do to an Enemy for one frame. <code>enemyhit_x</code> Pixel Unit The range of the Bullet's hitbox on the X axis. Affects enemies. <code>enemyhit_y</code> Pixel Unit The range of the Bullet's hitbox on the Y axis. Affects enemies. <code>blockhit_x</code> Pixel Unit The range of the Bullet's hitbox on the X axis. Affects map tiles. <code>blockhit_y</code> Pixel Unit The range of the Bullet's hitbox on the Y axis. Affects map tiles. <code>direct</code> Direction Direction of the Bullet. <code>ani_no</code> Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. <code>ani_wait</code> Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. <code>act_no</code> Number (Casted to integer) Act state value. This variable does nothing by itself, but can be used to switch between act states. <code>act_wait</code> Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. <code>count1</code> Number (Casted to integer) Counter value. This variable does nothing by itself. <code>count2</code> Number (Casted to integer) Counter value. This variable does nothing by itself."},{"location":"api/objects/bullet/#the-bullet-buffer","title":"The Bullet Buffer","text":"<p>Spawned Bullet in Cave Story are stored in a buffer (or list) of 64 entries.</p> <p>When the game spawns Bullet it checks trough the Bullet buffer and finds a spot that's not currently occupied by an alive Bullet and replaces that spot with the Bullet it's spawning. When the Bullet in that spot dies, the spot is freed out for when the game decides to spawn another Bullet again.</p> <p>Warning</p> <p>If you will be using any of the following functions for actively updating an Bullet you will have to actively retrieve the Bullet as well.</p>"},{"location":"api/objects/bullet/#modcsbulletspawn","title":"ModCS.Bullet.Spawn()","text":"<pre><code>ModCS.Bullet.Spawn(bullettype, x, y, direct)\n</code></pre> <p>Spawns a Bullet of Bullet Type <code>bullettype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>.</p> <p><code>direct</code> is an optional parameter and the Direction with which the Bullet will spawn.</p> <p>Returns a ModCS.Bullet of the spawned Bullet. </p>"},{"location":"api/objects/bullet/#modcsbulletgetbybufferindex","title":"ModCS.Bullet.GetByBufferIndex()","text":"<pre><code>ModCS.Bullet.GetByBufferIndex(index)\n</code></pre> <p>Directly gets <code>index</code> Bullet from the Bullet buffer.</p>"},{"location":"api/objects/caret/","title":"ModCS.Caret","text":"<p>The ModCS.Caret class represents Carets. Carets are game objects used for particles. They have no collision and draw over tiles. Unlike NPCs Carets only draw from the Caret Surface.</p> <p>A ModCS.Caret is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit X position of the Caret. <code>y</code> Pixel Unit Y position of the Caret. <code>xm</code> Pixel Unit X velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move(). <code>ym</code> Pixel Unit Y velocity of the Caret. This value does nothing by itself, but can be used with ModCS.Caret.Move(). <code>id</code> Caret Type ID ID of the Caret. <code>direct</code> Direction Direction of the Caret. This mostly does nothing by itself, but is used by different vanilla Carets as a parameter. <code>ani_no</code> Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. <code>ani_wait</code> Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. <code>act_no</code> Number (Casted to integer) Act state value. This variable does nothing by itself, but can be used to switch between act states. <code>act_wait</code> Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. <code>view_x</code> Pixel Unit X offset of the Caret sprite. <code>view_y</code> Pixel Unit Y offset of the Caret sprite."},{"location":"api/objects/caret/#the-caret-buffer","title":"The Caret Buffer","text":"<p>Spawned Carets in Cave Story are stored in a buffer (or list) of 64 entries.</p> <p>When the game spawns Carets it checks trough the Carets buffer and finds a spot that's not currently occupied by an alive Caret and replaces that spot with the Caret it's spawning. When the Caret in that spot dies, the spot is freed out for when the game decides to spawn another Caret again.</p> <p>Warning</p> <p>If you will be using any of the following functions for actively updating an Caret you will have to actively retrieve the Caret as well.</p>"},{"location":"api/objects/caret/#modcscaretspawn","title":"ModCS.Caret.Spawn()","text":"<pre><code>ModCS.Caret.Spawn(carettype, x, y, direct)\n</code></pre> <p>Spawns a Caret of Caret Type <code>carettype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>.</p> <p><code>direct</code> is an optional parameter and the Direction with which the Caret will spawn.</p> <p>Returns a ModCS.Caret of the spawned Caret. </p>"},{"location":"api/objects/caret/#modcscaretgetbybufferindex","title":"ModCS.Caret.GetByBufferIndex()","text":"<pre><code>ModCS.Caret.GetByBufferIndex(index)\n</code></pre> <p>Directly gets <code>index</code> Caret from the Caret buffer.</p>"},{"location":"api/objects/direction/","title":"Direction","text":"<p>Directions in Cave Story are represented by numbers.</p> Value Direction 0 Left 1 Up 2 Right 3 Down 4 Auto <p>Different objects interpret their direction parameter differently, although most of them follow this pattern. The Player and most NPCs only use the left and right directions.</p>"},{"location":"api/objects/npc/","title":"ModCS.Npc","text":"<p>The ModCS.Npc class represents NPCs (Also known as Entities). NPCs are game objects used for enemies, cutscenes, enemy projectiles and (some) bosses. Examples are Toroko, First Cave Critter, Puu Black, etc.</p> <p>A ModCS.Npc is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit X position of the NPC. <code>y</code> Pixel Unit Y position of the NPC. <code>xm</code> Pixel Unit X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move(). <code>ym</code> Pixel Unit Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move(). <code>xm2</code> Pixel Unit Alternative X velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2(). <code>ym2</code> Pixel Unit Alternative Y velocity of the NPC. This value does nothing by itself, but can be used with ModCS.Npc.Move2(). <code>tgt_x</code> Pixel Unit Target X value. This variable does nothing by itself. <code>tgt_y</code> Pixel Unit Target Y value. This variable does nothing by itself. <code>id</code> NPC Type ID ID of the NPC. <code>flag</code> Flag Flag of the NPC. <code>event</code> Event TSC Event of the NPC. <code>surf</code> Surface The surface that the NPC will draw from. <code>hit_voice</code> Sound ID The sound effect that will play when the NPC gets hit. <code>destroy_voice</code> Sound ID The sound effect that will play when the NPC dies. <code>life</code> Number (Casted to integer) The health points of the NPC. <code>damage</code> Number (Casted to integer) The amount of damage the NPC deals to the player upon touching. <code>exp</code> Number (Casted to integer) The XP worth of the NPC. <code>smoke_size</code> Number (Casted to integer) The amount of smoke the NPC will spawn after dying. Can be from 0 to 3 (0 being no smoke being spawned upon death). <code>direct</code> Direction Direction of the NPC. <code>ani_no</code> Number (Casted to integer) Animation frame value. This variable does nothing by itself, but can be used to switch between animation frames. <code>ani_wait</code> Number (Casted to integer) Animation timer value. This variable does nothing by itself, but can be used as a timer between animation frames. <code>act_no</code> Number (Casted to integer) Act state value. This variable does nothing by itself, but can be changed with the <code>&lt;ANP</code> TSC command. <code>act_wait</code> Number (Casted to integer) Act state timer value. This variable does nothing by itself, but can be used as a timer between act states. <code>count1</code> Number (Casted to integer) Counter value. This variable does nothing by itself. <code>count2</code> Number (Casted to integer) Counter value. This variable does nothing by itself. <code>pNpc</code> NPC Parent NPC value."},{"location":"api/objects/npc/#the-npc-buffer","title":"The NPC Buffer","text":"<p>Spawned NPCs in Cave Story are stored in a buffer (or list) of 512 entries. Although the NPC buffer size is 512, the game starts spawning NPCs at different positions in the buffer in different places. Examples include:</p> <ul> <li> <p>NPCs loaded from a PXE file start from 170.</p> </li> <li> <p>NPCs spawned by <code>&lt;SNP</code> start from 256.</p> </li> <li> <p>Water splash entities start from 0.</p> </li> </ul> <p>When the game spawns NPCs it checks trough the NPC buffer and finds a spot that's not currently occupied by an alive NPC and replaces that spot with the NPC it's spawning. When the NPC in that spot dies, the spot is freed out for when the game decides to spawn another NPC again.</p> <p>Warning</p> <p>If you will be using any of the following functions for actively updating an NPC you will have to actively retrieve the NPC as well.</p>"},{"location":"api/objects/npc/#modcsnpcgetbyevent","title":"ModCS.Npc.GetByEvent()","text":"<pre><code>ModCS.Npc.GetByEvent(event)\n</code></pre> <p>Searches the current buffer of spawned NPCs for one with an Event number <code>event</code> and returns a ModCS.Npc of that NPC. Returns a nil otherwise.</p>"},{"location":"api/objects/npc/#modcsnpcspawn","title":"ModCS.Npc.Spawn()","text":"<pre><code>ModCS.Npc.Spawn(npctype, x, y, start_index)\n</code></pre> <p>Spawns an NPC of NPC Type <code>npctype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>. If <code>start_index</code> is specified the NPC buffer start position for the NPC summon will be <code>start_index</code>. Otherwise the NPC buffer start position will be 256.</p> <p>Returns a ModCS.Npc of the spawned NPC. </p>"},{"location":"api/objects/npc/#modcsnpcspawn2","title":"ModCS.Npc.Spawn2()","text":"<pre><code>ModCS.Npc.Spawn2(npctype, x, y, xm, ym, direction, start_index)\n</code></pre> <p>Spawns an NPC of NPC Type <code>npctype</code> on Pixel Unit coordinates <code>x</code> and <code>y</code>, with <code>xm</code>, <code>ym</code>, and <code>direction</code> specified. If <code>start_index</code> is specified the NPC buffer start position for the NPC summon will be <code>start_index</code>. Otherwise the NPC buffer start position will be 256.</p> <p>Returns a ModCS.Npc of the spawned NPC. </p>"},{"location":"api/objects/npc/#modcsnpcgetbybufferindex","title":"ModCS.Npc.GetByBufferIndex()","text":"<pre><code>ModCS.Npc.GetByBufferIndex(index)\n</code></pre> <p>Directly gets <code>index</code> NPC from the NPC buffer.</p>"},{"location":"api/objects/pixel/","title":"Pixel Unit","text":"<p>A Pixel Unit represents an in-game space coordinate. While sprites on the screen use screen coordinates, objects such as NPCs, Carets, etc. use pixel units. You may use nonintegral values as pixel units but they will always be rounded to the nearest subpixel (1/512th of a pixel).</p>"},{"location":"api/objects/player/","title":"ModCS.Player","text":"<p>The ModCS.Player global object represents the player (Also known as My Character/ MYC).</p> <p>ModCS.Player is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>x</code> Pixel Unit The player's X position. <code>y</code> Pixel Unit The player's Y position. <code>tgt_x</code> Number (Casted to integer) The player's camera X focus position. <code>tgt_y</code> Number (Casted to integer) The player's camera Y focus position. <code>index_x</code> Number (Casted to integer) The player's X camera movement from facing direction. <code>index_y</code> Number (Casted to integer) The player's Y camera movement from facing direction. <code>xm</code> Pixel Unit X velocity of the Player. <code>ym</code> Pixel Unit Y velocity of the Player. <code>ani_no</code> Number (Casted to integer) Animation frame value. <code>ani_wait</code> Number (Casted to integer) Animation timer value. <code>direct</code> Direction The player's direction. <code>boost_fuel</code> Number (Casted to integer) The fuel of the Player's Booster. <code>air</code> Number (Casted to integer) Air value of the player. <code>fire_rate</code> Number (Casted to integer) Firerate of the players weapon (\"Rensha\") <code>ammo_empty</code> Number (Casted to integer) Timer of the \"empty\" caret until it vanishes. <code>shock</code> Number (Casted to integer) The players invincibility value. Caps out at 255. <code>splash</code> Number (Casted to integer, BOOL) Set to 1 if the player splashed in water. <code>down</code> Number (Casted to integer, BOOL) Set to 1 if the player is facing down. <code>up</code> Number (Casted to integer, BOOL) Set to 1 if the player is facing up. <code>ques</code> Number (Casted to integer) If 1, a question mark will spawn. <code>boost_sw</code> Number (Casted to integer) The boosters \"direction\". (Could be wrong.) <code>unit</code> Number (Casted to integer) The players \"unit\" value. Used for different movement types."},{"location":"api/objects/player/#modcsplayerishit","title":"ModCS.Player.IsHit()","text":"<pre><code>ModCS.Player.IsHit()\n</code></pre> <p>Returns true if the player is being hit. Returns false otherwise.</p>"},{"location":"api/objects/player/#modcsplayerislookingdown","title":"ModCS.Player.IsLookingDown()","text":"<pre><code>ModCS.Player.IsLookingDown()\n</code></pre> <p>Returns true if the player is looking down. Returns false otherwise.</p>"},{"location":"api/objects/player/#modcsplayerislookingup","title":"ModCS.Player.IsLookingUp()","text":"<pre><code>ModCS.Player.IsLookingUp()\n</code></pre> <p>Returns true if the player is looking up. Returns false otherwise.</p>"},{"location":"api/objects/player/#modcsplayergetlife","title":"ModCS.Player.GetLife()","text":"<pre><code>ModCS.Player.GetLife()\n</code></pre> <p>Returns the player's current life points.</p>"},{"location":"api/objects/player/#modcsplayeraddlife","title":"ModCS.Player.AddLife()","text":"<pre><code>ModCS.Player.AddLife(life)\n</code></pre> <p>Adds <code>life</code> to the player's life points.</p>"},{"location":"api/objects/player/#modcsplayergetmaxlife","title":"ModCS.Player.GetMaxLife()","text":"<pre><code>ModCS.Player.GetMaxLife()\n</code></pre> <p>Returns the player's current maximum life points.</p>"},{"location":"api/objects/player/#modcsplayeraddmaxlife","title":"ModCS.Player.AddMaxLife()","text":"<pre><code>ModCS.Player.AddMaxLife(life)\n</code></pre> <p>Adds <code>life</code> to the player's max life points.</p>"},{"location":"api/objects/player/#modcsplayerdamage","title":"ModCS.Player.Damage()","text":"<pre><code>ModCS.Player.Damage(damage)\n</code></pre> <p>Damages the player by <code>damage</code>.</p>"},{"location":"api/objects/player/#modcsplayersetrect","title":"ModCS.Player.SetRect()","text":"<pre><code>ModCS.Player.SetRect(left, top, right, bottom)\nModCS.Player.SetRect(rect)\n</code></pre> <p>Sets the Rect of the player to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of the player to that Rect instead.</p>"},{"location":"api/objects/player/#modcsplayergetrect","title":"ModCS.Player.GetRect()","text":"<pre><code>ModCS.Player.GetRect()\n</code></pre> <p>Returns the player's Rect.</p>"},{"location":"api/objects/player/#modcsplayeroffsetrect","title":"ModCS.Player.OffsetRect()","text":"<pre><code>ModCS.Player.OffsetRect(left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of the player.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/player/#modcsplayersetviewbox","title":"ModCS.Player.SetViewbox()","text":"<pre><code>ModCS.Player.SetViewbox(front, top, back, bottom)\nModCS.Player.SetViewbox(rangerect)\n</code></pre> <p>Sets the sprite offset of the Player to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the sprite offset of the Player to that RangeRect instead.</p>"},{"location":"api/objects/player/#modcsplayersethitbox","title":"ModCS.Player.SetHitbox()","text":"<pre><code>ModCS.Player.SetHitbox(front, top, back, bottom)\nModCS.Player.SetHitbox(rangerect)\n</code></pre> <p>Sets the hitbox of the Player to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the hitbox of the Player to that RangeRect instead.</p>"},{"location":"api/objects/player/#modcsplayergetviewbox","title":"ModCS.Player.GetViewbox()","text":"<pre><code>ModCS.Player.GetViewbox()\n</code></pre> <p>Returns the sprite offset RangeRect of the player.</p>"},{"location":"api/objects/player/#modcsplayergethitbox","title":"ModCS.Player.GetHitbox()","text":"<pre><code>ModCS.Player.GetHitbox()\n</code></pre> <p>Returns the hitbox RangeRect of the player.</p>"},{"location":"api/objects/player/#modcsplayersetarmsyoffset","title":"ModCS.Player.SetArmsYOffset()","text":"<pre><code>ModCS.Player.SetArmsYOffset(offset)\n</code></pre> <p>Sets the vertical sprite offset of the weapon sprite next to the player to <code>offset</code>.</p>"},{"location":"api/objects/player/#modcsplayerprocessair","title":"ModCS.Player.ProcessAir()","text":"<pre><code>ModCS.Player.ProcessAir()\n</code></pre> <p>Runs the vanilla games \"air processing\" function. This will already get ran if ModCS.Player.unit is 0.</p>"},{"location":"api/objects/range/","title":"ModCS.RangeRect","text":"<p>The ModCS.RangeRect class represents Range Rects (Also known as Other Rects). Unlike Drawing Rects Range Rects are centered rectangles. They are used for things such as NPC hitboxes.</p> <p>A ModCS.Rect is userdata. You may access and edit the following values from it:</p> Value Type Usage <code>front</code> Pixel Unit The radius from the center to the left side of the rectangle. <code>top</code> Pixel Unit The radius from the center to the top side of the rectangle. <code>back</code> Pixel Unit The radius from the center to the right side of the rectangle. <code>bottom</code> Pixel Unit The radius from the center to the bottom side of the rectangle."},{"location":"api/objects/range/#modcsrangerectcreate","title":"ModCS.RangeRect.Create()","text":"<pre><code>ModCS.RangeRect.Create(front, top, back, bottom)\n</code></pre> <p>Returns a ModCS.RangeRect.</p> <p>All parameters are optional. If any parameters are given, the returned ModCS.RangeRect will use those parameters as Range Rect values.</p>"},{"location":"api/objects/range/#modcsrangerectset","title":"ModCS.RangeRect.Set()","text":"<pre><code>ModCS.RangeRect.Set(rect, front, top, back, bottom)\n</code></pre> <p>Sets the ModCS.RangeRect given in the <code>rect</code> parameter to a ModCS.RangeRect with the following parameters.</p>"},{"location":"api/objects/bullet/bits/","title":"Bullet Bits","text":"<p>Bullet Bits (Also known as Bullet Flags) are toggles on Bullets that enable certain Bullet features. They can be turned on for individual Bullet Types.</p> <p>Note</p> <p>In the original game Bullet Bits are bit-wise. Because of this, many editors show bitwise information for them. For simplicity's sake ModCS uses normal decimal values.</p> Value Bitwise Value Usage 2 0x0004 Ignore tile collision. 3 0x0008 Don't vanish when hitting a tile. 4 0x0010 Go trough invincible NPCs. 5 0x0020 Be able to break Snack blocks. 6 0x0040 Go trough Snack blocks."},{"location":"api/objects/bullet/bits/#modcsbulletsetbit","title":"ModCS.Bullet.SetBit()","text":"<pre><code>ModCS.Bullet.SetBit(bul, bit)\n</code></pre> <p>Sets the bit <code>bit</code> for <code>bul</code>.</p>"},{"location":"api/objects/bullet/bits/#modcsbulletunsetbit","title":"ModCS.Bullet.UnsetBit()","text":"<pre><code>ModCS.Npc.UnsetBit(bul, bit)\n</code></pre> <p>Unsets the bit <code>bit</code> for <code>bul</code>.</p>"},{"location":"api/objects/bullet/bits/#modcsbulletcheckbit","title":"ModCS.Bullet.CheckBit()","text":"<pre><code>ModCS.Npc.CheckBit(bul, bit)\n</code></pre> <p>Returns true if the bit <code>bit</code> for <code>bul</code> is set. Returns false otherwise.</p>"},{"location":"api/objects/bullet/collision/","title":"NPC Collision detection","text":""},{"location":"api/objects/bullet/collision/#modcsbullettouchleftwall","title":"ModCS.Bullet.TouchLeftWall()","text":"<pre><code>ModCS.Bullet.TouchLeftWall(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a left wall.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchrightwall","title":"ModCS.Bullet.TouchRightWall()","text":"<pre><code>ModCS.Bullet.TouchRightWall(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a right wall.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchceiling","title":"ModCS.Bullet.TouchCeiling()","text":"<pre><code>ModCS.Bullet.TouchCeiling(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a ceiling.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchfloor","title":"ModCS.Bullet.TouchFloor()","text":"<pre><code>ModCS.Bullet.TouchFloor(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a floor.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchbottomsloperight","title":"ModCS.Bullet.TouchBottomSlopeRight()","text":"<pre><code>ModCS.Bullet.TouchBottomSlopeRight(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a bottom right slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchbottomslopeleft","title":"ModCS.Bullet.TouchBottomSlopeLeft()","text":"<pre><code>ModCS.Bullet.TouchBottomSlopeLeft(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a bottom left slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchtopsloperight","title":"ModCS.Bullet.TouchTopSlopeRight()","text":"<pre><code>ModCS.Bullet.TouchTopSlopeRight(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a top right slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchtopslopeleft","title":"ModCS.Bullet.TouchTopSlopeLeft()","text":"<pre><code>ModCS.Bullet.TouchTopSlopeLeft(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching a top left slope.</p>"},{"location":"api/objects/bullet/collision/#modcsbullettouchtile","title":"ModCS.Bullet.TouchTile()","text":"<pre><code>ModCS.Bullet.TouchTile(bul)\n</code></pre> <p>Returns true if <code>bul</code> is touching any type of collision tile.</p>"},{"location":"api/objects/bullet/functions/","title":"Bullet Manipulation Functions","text":""},{"location":"api/objects/bullet/functions/#modcsbulletsetrect","title":"ModCS.Bullet.SetRect()","text":"<pre><code>ModCS.Bullet.SetRect(bul, left, top, right, bottom)\nModCS.Bullet.SetRect(bul, rect)\n</code></pre> <p>Sets the Rect of <code>bul</code> to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of <code>bul</code> to that Rect instead.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletgetrect","title":"ModCS.Bullet.GetRect()","text":"<pre><code>ModCS.Bullet.GetRect(bul)\n</code></pre> <p>Returns <code>bul</code>'s Rect.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletoffsetrect","title":"ModCS.Bullet.OffsetRect()","text":"<pre><code>ModCS.Bullet.OffsetRect(bul, left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of <code>bul</code>.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletsetviewbox","title":"ModCS.Bullet.SetViewbox()","text":"<pre><code>ModCS.Bullet.SetViewbox(bul, front, top, back, bottom)\nModCS.Bullet.SetViewbox(bul, rangerect)\n</code></pre> <p>Sets the sprite offset of <code>bul</code> to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the sprite offset of <code>bul</code> to that RangeRect instead.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletgetviewbox","title":"ModCS.Bullet.GetViewbox()","text":"<pre><code>ModCS.Bullet.GetViewbox(bul)\n</code></pre> <p>Returns the sprite offset RangeRect of <code>bul</code>.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletactcode","title":"ModCS.Bullet.ActCode()","text":"<pre><code>ModCS.Bullet.ActCode(bul, bultype)\n</code></pre> <p><code>bultype</code> is an optional parameter. If not specified, it will be set to <code>bul</code>'s <code>id</code>.</p> <p>Runs the action code for Bullet Type <code>bultype</code> to <code>bul</code>.</p> <p>Note</p> <p>This will run the vanilla act code for <code>bultype</code>. To run any overwritten act functions, run functions from the <code>ModCS.Bullet.Act</code> array instead. </p>"},{"location":"api/objects/bullet/functions/#modcsbulletdelete","title":"ModCS.Bullet.Delete()","text":"<pre><code>ModCS.Bullet.Delete(bul)\n</code></pre> <p>Deletes <code>bul</code>.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletcountbyid","title":"ModCS.Bullet.CountByID()","text":"<pre><code>ModCS.Bullet.CountByID(id)\n</code></pre> <p>Counts how many Bullets of Bullet Type <code>id</code> are alive on the screen.</p>"},{"location":"api/objects/bullet/functions/#modcsbulletmove","title":"ModCS.Bullet.Move()","text":"<pre><code>ModCS.Bullet.Move(bul)\n</code></pre> <p>Adds <code>xm</code> and <code>ym</code> of <code>bul</code> to <code>bul</code>'s <code>x</code> and <code>y</code>. </p>"},{"location":"api/objects/bullet/id/","title":"Bullet Type IDs","text":"<p>An Bullet Type ID (Also known as Act ID or bullet code) is a number that defines an Bullet's type.</p>"},{"location":"api/objects/bullet/id/#bullet-table","title":"Bullet Table","text":"<p>A table of default Bullet properties are stored in a <code>bullet.tbl</code> file in the data folder. You may edit this table with your favorite Cave Story editor. When Bullets of a set type are spawned they will initially use properties from their Bullet Table entry, although these properties can be changed for Bullets with scripting at any time.</p> <p>Note</p> <p>Some vanilla Bullets change their damage or other features gotten from the Bullet Table dynamically. Changing the Bullet Table properties on these Bullet will most likely have little effect. </p>"},{"location":"api/objects/bullet/id/#bullet-type-reference","title":"Bullet Type reference","text":"Bullet Type ID Bullet 0 Null 1-3 Snake 4-6 Polar Star 7-9 Fireball 10-12 Machine Gun 13-15 Missile Launcher Rocket 16-18 Missile Launcher Explosion 19-21 Bubbline 22 Bubbline Level 3 Thorns 23 Blade Level 3 Slashes 24 Falling Spike (In \"Egg Corridor?\") 25-27 Blade 28-30 Super Missile Launcher Rocket 31-33 Super Missile Launcher Explosion 34-36 Nemesis 37-39 Spur 40-42 Spur Trail 42 Curly's Nemesis 44 Screen Nuke 45 Whimsical Star"},{"location":"api/objects/bullet/id/#overriding-bullets","title":"Overriding Bullets","text":"<p>ModCS allows you to override an Bullet type's act code. If a function in the <code>ModCS.Bullet.Act</code> array is defined with the index <code>X</code> (where <code>X</code> is the Bullet Type ID of the Bullet Type you want to override) in your Lua script the game will run that function instead of the built-in Bullet act code. A ModCS.Bullet will be passed as the first argument of the function when it's called.</p> Example <p>This example will set the Rect of Bullet Type 1 (The Snake Level 1 Bullet) to 16,0,32,16. <pre><code>ModCS.Bullet.Act[0] = function(bul)\n    bul:SetRect(16,0,32,16)\nend\n</code></pre></p>"},{"location":"api/objects/caret/functions/","title":"Caret Manipulation Functions","text":""},{"location":"api/objects/caret/functions/#modcscaretsetrect","title":"ModCS.Caret.SetRect()","text":"<pre><code>ModCS.Caret.SetRect(crt, left, top, right, bottom)\nModCS.Caret.SetRect(crt, rect)\n</code></pre> <p>Sets the Rect of <code>crt</code> to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of <code>crt</code> to that Rect instead.</p>"},{"location":"api/objects/caret/functions/#modcscaretgetrect","title":"ModCS.Caret.GetRect()","text":"<pre><code>ModCS.Caret.GetRect(crt)\n</code></pre> <p>Returns <code>crt</code>'s Rect.</p>"},{"location":"api/objects/caret/functions/#modcscaretoffsetrect","title":"ModCS.Caret.OffsetRect()","text":"<pre><code>ModCS.Caret.OffsetRect(crt, left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of <code>crt</code>.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/caret/functions/#modcscaretactcode","title":"ModCS.Caret.ActCode()","text":"<pre><code>ModCS.Caret.ActCode(crt, carettype)\n</code></pre> <p><code>carettype</code> is an optional parameter. If not specified, it will be set to <code>caret</code>'s <code>id</code>.</p> <p>Runs the action code for Caret Type <code>carettype</code> to <code>crt</code>.</p> <p>Note</p> <p>This will run the vanilla act code for <code>carettype</code>. To run any overwritten act functions, run functions from the <code>ModCS.Caret.Act</code> array instead.  </p>"},{"location":"api/objects/caret/functions/#modcscaretdelete","title":"ModCS.Caret.Delete()","text":"<pre><code>ModCS.Caret.Delete(crt)\n</code></pre> <p>Deletes <code>crt</code>.</p>"},{"location":"api/objects/caret/functions/#modcscaretmove","title":"ModCS.Caret.Move()","text":"<pre><code>ModCS.Caret.Move(crt)\n</code></pre> <p>Adds <code>xm</code> and <code>ym</code> of <code>crt</code> to <code>crt</code>'s <code>x</code> and <code>y</code>. </p>"},{"location":"api/objects/caret/id/","title":"Caret Type IDs","text":"<p>A Caret Type ID (Also known as Act ID or character code) is a number that defines an Caret's type.</p>"},{"location":"api/objects/caret/id/#caret-table","title":"Caret Table","text":"<p>A table of default Caret sprite offsets are stored in a <code>caret.tbl</code> file in the data folder. When Carets of a set type are spawned they will initially use sprite offsets from their Caret Table entry, although these offsets can be changed for Carets with scripting at any time.</p>"},{"location":"api/objects/caret/id/#caret-type-reference","title":"Caret Type reference","text":"Caret Type ID Caret 0 Null 1 Bubble 2 Projectile dissipation 3 Shoot Particle 4 Snake Afterimage (Unused) 5 Zzz Sleeping Particles 6 Snake Afterimage (Duplicate) 7 Booster Particle 8 Drowned Player 9 Interact Question mark 10 'Level Up!' 11 Red hurt particles 12 Explosion flash 13 White circle particles (Used by Demon Crown and when the player bumps onto a ceiling) 14 Broken caret 15 Small projectile dissipation 16 'Empty!' 17 'PUSH JUMP KEY!' (Unused)"},{"location":"api/objects/caret/id/#overriding-carets","title":"Overriding Carets","text":"<p>ModCS allows you to override a Caret type's act code.  If a function in the <code>ModCS.Caret.Act</code> array is defined with the index <code>X</code> (where <code>X</code> is the Caret Type ID of the Caret Type you want to override) in your Lua script the game will run that function instead of the built-in Caret act code. A ModCS.Caret will be passed as the first argument of the function when it's called.</p> Example <p>This example will set the Rect of Caret Type 1 to 0,0,8,8. <pre><code>ModCS.Caret.Act[1] = function(crt)\n    crt:SetRect(0,0,8,8)\nend\n</code></pre></p>"},{"location":"api/objects/npc/bits/","title":"NPC Bits","text":"<p>NPC Bits (Also known as NPC Flags) are toggles on NPCs that enable certain NPC features. They can be turned on for individual NPC Types as well as for individual NPCs in a PXE file.</p> <p>Note</p> <p>In the original game NPC Bits are bit-wise. Because of this, many editors show bitwise information for them. For simplicity's sake ModCS uses normal decimal values.</p> Value Bitwise Value Usage 0 0x0001 Collision against player - Pushes player out. 1 0x0002 Ignore tile attribute 44. 2 0x0004 Cannot be hurt and has a different hit effect when hit by a bullet. 3 0x0008 Ignore tile collision. 4 0x0010 The top of the NPC is bouncy. 5 0x0020 The NPC is shootable. 6 0x0040 Collision against player. 7 0x0080 Rear and top of the NPC does not hurt the player. 8 0x0100 The TSC Event specified in the <code>event</code> parameter of the ModCS.Npc will run when the player touches the NPC. 9 0x0200 The TSC Event specified in the <code>event</code> parameter of the ModCS.Npc will run when the NPC dies. 11 0x0800 The NPC will not spawn unless the Flag specified in the <code>flag</code> parameter of ModCS.Npc is set. 12 0x1000 The NPC will spawn with the <code>direct</code> parameter of the ModCS.Npc being set to 2. 13 0x2000 If the player interacts with the NPC the TSC Event specified in the <code>event</code> parameter of the ModCS.Npc will run. 14 0x4000 The NPC will not spawn if the Flag specified in the <code>flag</code> parameter of ModCS.Npc is set. 15 0x8000 Damage dealt to the NPC will show in a damage indicator."},{"location":"api/objects/npc/bits/#modcsnpcsetbit","title":"ModCS.Npc.SetBit()","text":"<pre><code>ModCS.Npc.SetBit(npc, bit)\n</code></pre> <p>Sets the bit <code>bit</code> for <code>npc</code>.</p>"},{"location":"api/objects/npc/bits/#modcsnpcunsetbit","title":"ModCS.Npc.UnsetBit()","text":"<pre><code>ModCS.Npc.UnsetBit(npc, bit)\n</code></pre> <p>Unsets the bit <code>bit</code> for <code>npc</code>.</p>"},{"location":"api/objects/npc/bits/#modcsnpccheckbit","title":"ModCS.Npc.CheckBit()","text":"<pre><code>ModCS.Npc.CheckBit(npc, bit)\n</code></pre> <p>Returns true if the bit <code>bit</code> for <code>npc</code> is set. Returns false otherwise.</p>"},{"location":"api/objects/npc/collision/","title":"NPC Collision detection","text":""},{"location":"api/objects/npc/collision/#modcsnpctouchleftwall","title":"ModCS.Npc.TouchLeftWall()","text":"<pre><code>ModCS.Npc.TouchLeftWall(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a left wall.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchrightwall","title":"ModCS.Npc.TouchRightWall()","text":"<pre><code>ModCS.Npc.TouchRightWall(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a right wall.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchceiling","title":"ModCS.Npc.TouchCeiling()","text":"<pre><code>ModCS.Npc.TouchCeiling(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a ceiling.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchfloor","title":"ModCS.Npc.TouchFloor()","text":"<pre><code>ModCS.Npc.TouchFloor(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a floor.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchsloperight","title":"ModCS.Npc.TouchSlopeRight()","text":"<pre><code>ModCS.Npc.TouchSlopeRight(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a right slope.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchslopeleft","title":"ModCS.Npc.TouchSlopeLeft()","text":"<pre><code>ModCS.Npc.TouchSlopeLeft(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching a left slope.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchtile","title":"ModCS.Npc.TouchTile()","text":"<pre><code>ModCS.Npc.TouchTile(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching any type of collision tile.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchwater","title":"ModCS.Npc.TouchWater()","text":"<pre><code>ModCS.Npc.TouchWater(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching water.</p>"},{"location":"api/objects/npc/collision/#modcsnpctouchplayer","title":"ModCS.Npc.TouchPlayer()","text":"<pre><code>ModCS.Npc.TouchPlayer(npc)\n</code></pre> <p>Returns true if <code>npc</code> is touching the player.</p>"},{"location":"api/objects/npc/collision/#modcsnpchitflag","title":"ModCS.Npc.HitFlag()","text":"<pre><code>ModCS.Npc.HitFlag(npc, flag)\n</code></pre> <p>Returns true if the <code>npc</code> has the <code>hit_flag</code>, \"<code>flag</code>\" active.</p>"},{"location":"api/objects/npc/functions/","title":"NPC Manipulation Functions","text":""},{"location":"api/objects/npc/functions/#modcsnpcsetrect","title":"ModCS.Npc.SetRect()","text":"<pre><code>ModCS.Npc.SetRect(npc, left, top, right, bottom)\nModCS.Npc.SetRect(npc, rect)\n</code></pre> <p>Sets the Rect of <code>npc</code> to a Rect with <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>.</p> <p>If a <code>rect</code> is specified, set the Rect of <code>npc</code> to that Rect instead.</p>"},{"location":"api/objects/npc/functions/#modcsnpcgetrect","title":"ModCS.Npc.GetRect()","text":"<pre><code>ModCS.Npc.GetRect(npc)\n</code></pre> <p>Returns <code>npc</code>'s Rect.</p>"},{"location":"api/objects/npc/functions/#modcsnpcoffsetrect","title":"ModCS.Npc.OffsetRect()","text":"<pre><code>ModCS.Npc.OffsetRect(npc, left, top, right, bottom)\n</code></pre> <p>Adds <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> to the the <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> values of the Rect of <code>npc</code>.</p> <p><code>right</code> and <code>bottom</code> are optional parameters. If they are not specified, <code>left</code> and <code>top</code> will be used in their place instead.</p>"},{"location":"api/objects/npc/functions/#modcsnpcsethitbox","title":"ModCS.Npc.SetHitbox()","text":"<pre><code>ModCS.Npc.SetHitbox(npc, front, top, back, bottom)\nModCS.Npc.SetHitbox(npc, rangerect)\n</code></pre> <p>Sets the hitbox of <code>npc</code> to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the hitbox of <code>npc</code> to that RangeRect instead.</p> <p>Warning</p> <p>When editing NPC hitboxes make sure that the front and back values of the hitbox are the same, otherwise you might get weird hitbox behavior.</p>"},{"location":"api/objects/npc/functions/#modcsnpcgethitbox","title":"ModCS.Npc.GetHitbox()","text":"<pre><code>ModCS.Npc.GetHitbox(npc)\n</code></pre> <p>Returns the hitbox RangeRect of <code>npc</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpcsetviewbox","title":"ModCS.Npc.SetViewbox()","text":"<pre><code>ModCS.Npc.SetViewbox(npc, front, top, back, bottom)\nModCS.Npc.SetViewbox(npc, rangerect)\n</code></pre> <p>Sets the sprite offset of <code>npc</code> to a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code>.</p> <p>If a <code>rangerect</code> is specified, set the sprite offset of <code>npc</code> to that RangeRect instead.</p>"},{"location":"api/objects/npc/functions/#modcsnpcgetviewbox","title":"ModCS.Npc.GetViewbox()","text":"<pre><code>ModCS.Npc.GetViewbox(npc)\n</code></pre> <p>Returns the sprite offset RangeRect of <code>npc</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpcactcode","title":"ModCS.Npc.ActCode()","text":"<pre><code>ModCS.Npc.ActCode(npc, npctype)\n</code></pre> <p><code>npctype</code> is an optional parameter. If not specified, it will be set to <code>npc</code>'s <code>id</code>.</p> <p>Runs the action code for NPC Type <code>npctype</code> to <code>npc</code>.</p> <p>Note</p> <p>This will run the vanilla act code for <code>npctype</code>. To run any overwritten act functions, run functions from the <code>ModCS.Npc.Act</code> array instead. </p>"},{"location":"api/objects/npc/functions/#modcsnpcishit","title":"ModCS.Npc.IsHit()","text":"<pre><code>ModCS.Npc.IsHit(npc)\n</code></pre> <p>Returns true if <code>npc</code> is being hit by a bullet. Returns false otherwise.</p>"},{"location":"api/objects/npc/functions/#modcsnpcdelete","title":"ModCS.Npc.Delete()","text":"<pre><code>ModCS.Npc.Delete(npc)\n</code></pre> <p>Deletes <code>npc</code>. Same effect as <code>&lt;DNP</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpckill","title":"ModCS.Npc.Kill()","text":"<pre><code>ModCS.Npc.Kill(npc)\n</code></pre> <p>Kills <code>npc</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpckillonnextframe","title":"ModCS.Npc.KillOnNextFrame()","text":"<pre><code>ModCS.Npc.KillOnNextFrame(npc)\n</code></pre> <p>Sets <code>npc</code> for deletion on the next frame.</p>"},{"location":"api/objects/npc/functions/#modcsnpcmove","title":"ModCS.Npc.Move()","text":"<pre><code>ModCS.Npc.Move(npc)\n</code></pre> <p>Adds <code>xm</code> and <code>ym</code> of <code>npc</code> to <code>npc</code>'s <code>x</code> and <code>y</code>. </p>"},{"location":"api/objects/npc/functions/#modcsnpcmove2","title":"ModCS.Npc.Move2()","text":"<pre><code>ModCS.Npc.Move2(npc)\n</code></pre> <p>Adds <code>xm2</code> and <code>ym2</code> of <code>npc</code> to <code>npc</code>'s <code>x</code> and <code>y</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpcmove3","title":"ModCS.Npc.Move3()","text":"<pre><code>ModCS.Npc.Move3(npc, xv, yv)\n</code></pre> <p>Adds <code>xv</code> and <code>yv</code> from the function argument to <code>npc</code>'s <code>x</code> and <code>y</code>.</p>"},{"location":"api/objects/npc/functions/#modcsnpctriggerbox","title":"ModCS.Npc.TriggerBox()","text":"<pre><code>ModCS.Npc.TriggerBox(npc, front, top, back, bottom)\nModCS.Npc.TriggerBox(npc, rangerect)\n</code></pre> <p>Returns true if the player is in a range of a RangeRect with <code>front</code>, <code>top</code>, <code>back</code>, <code>bottom</code> to <code>npc</code>. Returns false otherwise.</p> <p>If a <code>rangerect</code> is specified, set the range used will be the one of the RangeRect instead.</p>"},{"location":"api/objects/npc/id/","title":"NPC Type IDs","text":"<p>An NPC Type ID (Also known as Act ID or character code) is a number that defines an NPC's type.</p>"},{"location":"api/objects/npc/id/#npc-table","title":"NPC Table","text":"<p>A table of default NPC properties are stored in a <code>npc.tbl</code> file in the data folder. You may edit this table with your favorite Cave Story editor. When NPCs of a set type are spawned they will initially use properties from their NPC Table entry, although these properties can be changed for NPCs with scripting at any time.</p> <p>Note</p> <p>Some vanilla NPCs change their damage or other features gotten from the NPC Table dynamically. Changing the NPC Table properties on these NPCs will most likely have little effect. </p> NPC Table parameters on different editors <p>Different Cave Story editors use different terminology on NPC Table parameters. This section translates all of them to ModCS API equivalents.</p> Booster's Lab <p></p> The King's Table <p></p> Cave Editor <p></p> <ol> <li><code>life</code> parameter of a ModCS.Npc</li> <li><code>damage</code> parameter of a ModCS.Npc</li> <li><code>exp</code> parameter of a ModCS.Npc</li> <li>NPC Bits</li> <li>NPC Hitbox</li> <li>NPC Viewbox</li> <li><code>surf</code> parameter of a ModCS.Npc</li> <li><code>hit_voice</code> parameter of a ModCS.Npc</li> <li><code>destroy_voice</code> parameter of a ModCS.Npc</li> <li><code>smoke_size</code> parameter of a ModCS.Npc</li> </ol>"},{"location":"api/objects/npc/id/#npc-type-reference","title":"NPC Type reference","text":"<p>... Here I would put my own NPC Type reference table but I'm currently too lazy. Please refer to your map editor's NPC list or this Cave Story NPC Spreadsheet instead.</p>"},{"location":"api/objects/npc/id/#overriding-npcs","title":"Overriding NPCs","text":"<p>ModCS allows you to override an NPC type's act code. If a function in the <code>ModCS.Npc.Act</code> array is defined with the index <code>X</code> (where <code>X</code> is the NPC Type ID of the NPC Type you want to override) in your Lua script the game will run that function instead of the built-in NPC act code. A ModCS.Npc will be passed as the first argument of the function when it's called.</p> Example <p>This example will set the Rect of NPC Type 0 (The Null NPC) to 16,0,32,16. <pre><code>ModCS.Npc.Act[0] = function(npc)\n    npc:SetRect(16,0,32,16)\nend\n</code></pre></p>"},{"location":"api/objects/player/collision/","title":"Player Collision detection","text":""},{"location":"api/objects/player/collision/#modcsplayertouchleftwall","title":"ModCS.Player.TouchLeftWall()","text":"<pre><code>ModCS.Player.TouchLeftWall()\n</code></pre> <p>Returns true if the player is touching a left wall.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchrightwall","title":"ModCS.Player.TouchRightWall()","text":"<pre><code>ModCS.Player.TouchRightWall()\n</code></pre> <p>Returns true if the player is touching a right wall.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchceiling","title":"ModCS.Player.TouchCeiling()","text":"<pre><code>ModCS.Player.TouchCeiling()\n</code></pre> <p>Returns true if the player is touching a ceiling.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchfloor","title":"ModCS.Player.TouchFloor()","text":"<pre><code>ModCS.Player.TouchFloor()\n</code></pre> <p>Returns true if the player is touching a floor.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchsloperight","title":"ModCS.Player.TouchSlopeRight()","text":"<pre><code>ModCS.Player.TouchSlopeRight()\n</code></pre> <p>Returns true if the player is touching a right slope.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchslopeleft","title":"ModCS.Player.TouchSlopeLeft()","text":"<pre><code>ModCS.Player.TouchSlopeLeft()\n</code></pre> <p>Returns true if the player is touching a left slope.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchtile","title":"ModCS.Player.TouchTile()","text":"<pre><code>ModCS.Player.TouchTile()\n</code></pre> <p>Returns true if the player is touching any type of collision tile.</p>"},{"location":"api/objects/player/collision/#modcsplayertouchwater","title":"ModCS.Player.TouchWater()","text":"<pre><code>ModCS.Player.TouchWater()\n</code></pre> <p>Returns true if the player is touching water.</p>"},{"location":"api/objects/player/collision/#modcsplayerhitflag","title":"ModCS.Player.HitFlag()","text":"<pre><code>ModCS.Player.HitFlag(flag)\n</code></pre> <p>Returns true if the players <code>hit_flag</code> value has the flag specified.</p>"},{"location":"api/objects/player/equip/","title":"Player Equip","text":"<p>Player Equip Values are toggles that enable certain features for the player. They are mostly used in Cave Story for checking equipped items.</p> <p>Note</p> <p>Equip values are bit-wise. This means if you checked for \"3\", that would be like 1 and 2.</p> Value Bitwise Value Usage 0 0x0001 Booster v0.8 (Ignored if v2.0 is equipped) 1 0x0002 Map System 2 0x0004 Arms Barrier 3 0x0008 Turbocharge 4 0x0010 Air Tank 5 0x0020 Booster v2.0 6 0x0040 Mimiga Mask 7 0x0080 Whimsical Star 8 0x0100 Nikumaru Counter"},{"location":"api/objects/player/equip/#modcsplayerequip","title":"ModCS.Player.Equip()","text":"<pre><code>ModCS.Player.Equip(value)\n</code></pre> <p>Sets the equip value <code>value</code>.</p>"},{"location":"api/objects/player/equip/#modcsplayerunequip","title":"ModCS.Player.Unequip()","text":"<pre><code>ModCS.Player.Unequip(value)\n</code></pre> <p>Unsets the equip value <code>value</code>.</p>"},{"location":"api/objects/player/equip/#modcsplayerhasequipped","title":"ModCS.Player.HasEquipped()","text":"<pre><code>ModCS.Player.HasEquipped(value)\n</code></pre> <p>Returns true if the equip value <code>value</code> is set. Returns false otherwise.</p>"},{"location":"api/sound/music/","title":"ModCS.Music","text":"<p>The ModCS.Music namespace contains functions related to playing music.</p>"},{"location":"api/sound/music/#music-id-reference","title":"Music ID reference","text":"Music ID Name Internal Name 0 None XXXX 1 Mischievous Robot WANPAKU 2 Safety ANZEN 3 Game Over GAMEOVER 4 Gravity GRAVITY 5 On To Grasstown WEED 6 Meltdown 2 MDOWN2 7 Eyes of Flame FIREEYE 8 Gestation VIVI 9 Mimiga Town MURA 10 Get Item FANFALE1 11 Balrog's Theme GINSUKE 12 Cemetery CEMETERY 13 Plant PLANT 14 Pulse KODOU 15 Victory FANFALE3 16 Get Life Capsule FANFALE2 17 Tyrant DR 18 Run ESCAPE 19 Jenka 1 JENKA 20 Labyrinth Fight MAZE 21 Access ACCESS 22 Oppression IRONH 23 Geothermal GRAND 24 Cave Story CURLY 25 Moonsong OSIDE 26 Hero's End REQUIEM 27 Scorching Back WANPAK2 28 Quiet QUIET 29 Final Cave LASTCAVE 30 Balcony BALCONY 31 Charge LASTBTL 32 Last Battle LASTBT3 33 The Way Back Home ENDING 34 Zombie ZONBIE 35 Break Down BDOWN 36 Running Hell HELL 37 Jenka 2 JENKA2 38 Living Waterway MARINE 39 Seal Chamber BALLOS 40 Toroko's Theme TOROKO 41 White Stone Wall WHITE"},{"location":"api/sound/music/#modcsmusicplay","title":"ModCS.Music.Play()","text":"<pre><code>ModCS.Music.Play(id)\n</code></pre> <p>Changes the current music playing to music <code>id</code>.</p>"},{"location":"api/sound/music/#modcsmusicgetcurrent","title":"ModCS.Music.GetCurrent()","text":"<pre><code>ModCS.Music.GetCurrent()\n</code></pre> <p>Returns the ID of the current track.</p>"},{"location":"api/sound/music/#modcsmusicgetold","title":"ModCS.Music.GetOld()","text":"<pre><code>ModCS.Music.GetOld()\n</code></pre> <p>Returns the ID of the last track played.</p>"},{"location":"api/sound/music/#modcsmusicgetposition","title":"ModCS.Music.GetPosition()","text":"<pre><code>ModCS.Music.GetPosition()\n</code></pre> <p>Returns the position number of the current track.</p>"},{"location":"api/sound/music/#modcsmusicgetoldposition","title":"ModCS.Music.GetOldPosition()","text":"<pre><code>ModCS.Music.GetOldPosition()\n</code></pre> <p>Returns the position number of the last track played.</p>"},{"location":"api/sound/music/#modcsmusicsetposition","title":"ModCS.Music.SetPosition()","text":"<pre><code>ModCS.Music.SetPosition(x)\n</code></pre> <p>Sets the position number of the current track to <code>x</code>.</p>"},{"location":"api/sound/music/#modcsmusicsetvolume","title":"ModCS.Music.SetVolume()","text":"<pre><code>ModCS.Music.SetVolume(vol)\n</code></pre> <p>Sets the volume of the current track to <code>vol</code>. </p>"},{"location":"api/sound/sound/","title":"ModCS.Sound","text":"<p>The ModCS.Sound namespace contains functions related to playing different sound effects.</p>"},{"location":"api/sound/sound/#sound-effects-id-reference","title":"Sound Effects ID reference","text":"<p>... Here I would put my own sound effects table but I'm currently too lazy. Please refer to your map editor's sound effects list.</p>"},{"location":"api/sound/sound/#modcssoundplay","title":"ModCS.Sound.Play()","text":"<pre><code>ModCS.Sound.Play(id, loop)\n</code></pre> <p>Plays sound effect <code>id</code>.</p> <p><code>loop</code> is an optional parameter and a Boolean. If set to true the given sound effect will play on loop.</p>"},{"location":"api/sound/sound/#modcssoundstop","title":"ModCS.Sound.Stop()","text":"<pre><code>ModCS.Npc.Stop(id)\n</code></pre> <p>Stop playing sound effect <code>id</code>.</p>"},{"location":"api/sound/sound/#modcssoundchangefrequency","title":"ModCS.Sound.ChangeFrequency","text":"<pre><code>ModCS.Sound.ChangeFrequency(id, freq)\n</code></pre> <p>Change the frequency of sound effect <code>id</code> to <code>freq</code>.</p>"},{"location":"api/sound/sound/#modcssoundchangevolume","title":"ModCS.Sound.ChangeVolume","text":"<pre><code>ModCS.Sound.ChangeFrequency(id, volume)\n</code></pre> <p>Change the volume of sound effect <code>id</code> to <code>volume</code>.</p>"},{"location":"api/sound/sound/#modcssoundchangepan","title":"ModCS.Sound.ChangePan","text":"<pre><code>ModCS.Sound.ChangePan(id, pan)\n</code></pre> <p>Change the panning of sound effect <code>id</code> to <code>pan</code>.</p>"}]}